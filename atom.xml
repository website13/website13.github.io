<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Welcome to my Blog</title>
  
  
  <link href="http://website13.github.io/atom.xml" rel="self"/>
  
  <link href="http://website13.github.io/"/>
  <updated>2022-07-31T10:21:23.250Z</updated>
  <id>http://website13.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java入门教程：（十七）新增、修改、删除</title>
    <link href="http://website13.github.io/2021/08/30/JAVA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%9A%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%E6%96%B0%E5%A2%9E%E3%80%81%E4%BF%AE%E6%94%B9%E3%80%81%E5%88%A0%E9%99%A4/"/>
    <id>http://website13.github.io/2021/08/30/JAVA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%9A%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%E6%96%B0%E5%A2%9E%E3%80%81%E4%BF%AE%E6%94%B9%E3%80%81%E5%88%A0%E9%99%A4/</id>
    <published>2021-08-30T07:13:54.000Z</published>
    <updated>2022-07-31T10:21:23.250Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>首先，我们需要建一张学生表，执行如下sql</p><p><img src="https://img-blog.csdnimg.cn/20210830140703287.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR57qv5rSB5YWo6Lqr6YO957qv5rSB,size_13,color_FFFFFF,t_70,g_se,x_16"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `xuesheng` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `xingming` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">  `shengri` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;生日&#x27;</span>,</span><br><span class="line">  `xuehao` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">  `xingbie` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">  `banji` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;班级&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_unicode_ci;</span><br></pre></td></tr></table></figure><p>执行sql，执行时一定要先选中要执行的sql，然后右键选运行已选择的（如下图），否则如果直接点上面的运行按钮，如果你这里面写了多条sql，就全部都 执行了，容易出问题。</p><p><img src="https://img-blog.csdnimg.cn/20210830151524983.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR57qv5rSB5YWo6Lqr6YO957qv5rSB,size_15,color_FFFFFF,t_70,g_se,x_16"></p><p> 执行完sql之后，点击表，然后按F5就能刷新出来了</p><p><img src="https://img-blog.csdnimg.cn/2021083014120772.png"></p><p>按如下操作就能按到一张表的建表语句了<img src="https://img-blog.csdnimg.cn/20210830141625964.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR57qv5rSB5YWo6Lqr6YO957qv5rSB,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>注意点：</p><p>1、每条sql以分号结束；2、写sql也要和写java一样，有自己的格式，切不可写成一行或者胡乱换行，这样只会让自己阅读和改错的时候造成困难。3、某个字段的类型并不一定需要按照字段的真实类型创建，例如生日和创建时间字段我就不用date类型，性别字段我就不设置长度1，这些在实际工作中按照公司要求来就行了。</p><h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><p>语法：insert into 表名(字段1,字段2,字段3,……) values (值1,值2,值3,……)</p><p>插入三条数据sql如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> xuesheng(</span><br><span class="line">xingming,</span><br><span class="line">shengri,</span><br><span class="line">xuehao,</span><br><span class="line">xingbie,</span><br><span class="line">banji,</span><br><span class="line">create_time</span><br><span class="line">)</span><br><span class="line"><span class="keyword">values</span>(</span><br><span class="line"><span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;2000-01-01&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;201208300001&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;男&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;1201&#x27;</span>,</span><br><span class="line">now()#mysql中使用#或者<span class="comment">--空格来注释</span></span><br><span class="line">),</span><br><span class="line">(</span><br><span class="line"><span class="string">&#x27;李四&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;2000-02-01&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;201208300002&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;女&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;1201&#x27;</span>,</span><br><span class="line">now()<span class="comment">-- now是mysql的函数，返回当前时间</span></span><br><span class="line">),</span><br><span class="line">(</span><br><span class="line"><span class="string">&#x27;王五&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;2000-03-01&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;201208300003&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;男&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;1201&#x27;</span>,</span><br><span class="line">now()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行完之后，双击打开xuesheng表或者在已打开的xuesheng表里按f5刷新就能看到数据了</p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>update 表名 set 字段&#x3D;’??‘ where 字段&#x3D;’??‘</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> xuesheng</span><br><span class="line"><span class="keyword">set</span> xingbie<span class="operator">=</span><span class="string">&#x27;男&#x27;</span></span><br><span class="line"><span class="keyword">where</span> xuehao<span class="operator">=</span><span class="string">&#x27;201208300002&#x27;</span></span><br></pre></td></tr></table></figure><p>执行完之后刷新表，看到李四的性别变为男了</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>语法：delete from 表名 where 条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> xuesheng <span class="keyword">where</span> xuehao<span class="operator">=</span><span class="string">&#x27;201208300002&#x27;</span></span><br></pre></td></tr></table></figure><p>执行完刷新表，看到李四被删除了。</p><h2 id="小结-amp-一些说明"><a href="#小结-amp-一些说明" class="headerlink" title="小结&amp;一些说明"></a>小结&amp;一些说明</h2><p>1、增删改查是最基础的数据库操作，本节只说了前三种，因为查询语法多变，情况复杂所以放在下一张统一讲解。</p><p>2、update和delete中的where是可选条件，不加的话就会更新&#x2F;删除表中的全部数据。</p><p>3、mysql的注释在上面也写清楚了分为“#”和“--空格”两种。</p><p>4、建表时已经把id字段设置为主键并且是自增的了，自增意味着你insert时不需要专门去插入id字段，mysql会字段帮你插入，主键意味着（1）这个字段的值在全表中唯一，这样以后就可以专门根据这个字段去修改或者删除数据了（2）主键自带索引，使用这个字段作为条件进行修改或者删除或者排序时效率会提高，至于在别的普通字段上增加索引，自己有兴趣去查一下，以后不再讲解了，因为我的初衷是让初学者能在java中使用mysql而不是让初学者成为负担。</p><p>5、update和select（查询）时，表名后面是可以加别名的，如delete from xuesheng a where a.xuehao&#x3D;’201208300002’，这样做的目的一是当你写出a.的时候Navicat会帮你自动把该表的所有字段列出来让你选择非常方便，二是一条语句通常会操作不只一张表，我们给表起a、b、c、d别名时，点字段的时候就非常的明确该字段是对应的那张表了，以后的sql我都会加上别名。</p><p>6、你可以保存（Ctrl+S）你的sql，下次就能在这里打开<img src="https://img-blog.csdnimg.cn/20210830151626376.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5oiR57qv5rSB5YWo6Lqr6YO957qv5rSB,size_13,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;前置条件&quot;&gt;&lt;a href=&quot;#前置条件&quot; class=&quot;headerlink&quot; title=&quot;前置条件&quot;&gt;&lt;/a&gt;前置条件&lt;/h2&gt;&lt;p&gt;首先，我们需要建一张学生表，执行如下sql&lt;/p&gt;
&lt;p&gt;&lt;img src</summary>
      
    
    
    
    <category term="Java" scheme="http://website13.github.io/categories/Java/"/>
    
    
    <category term="mysql 增删改查 mysql教程 java教程" scheme="http://website13.github.io/tags/mysql-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-mysql%E6%95%99%E7%A8%8B-java%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java入门教程：（十六）创建数据库、表</title>
    <link href="http://website13.github.io/2021/05/12/JAVA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%9A%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E8%A1%A8/"/>
    <id>http://website13.github.io/2021/05/12/JAVA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%9A%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E8%A1%A8/</id>
    <published>2021-05-12T10:03:52.000Z</published>
    <updated>2022-07-31T10:21:26.482Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>关于mysql介绍网上一搜一大堆，这里就不再介绍了，我之后的mysql文章只讲最简单基础的用法，主要是为java程序服务的。如果有兴趣多学一点mysql的话，建议去<a href="https://www.runoob.com/mysql/mysql-tutorial.html">https://www.runoob.com/mysql/mysql-tutorial.html</a>中系统学习，我看了下如果拿出全部时间的话大概一两天就能学完，我也强烈简历先去看看，然后就可以直接跳过之后的关于mysql的文章了。</p><h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><p>右键-新建数据库</p><p><img src="https://img-blog.csdnimg.cn/20210512162057866.png"></p><p>输入库名、选择字符集和排序规则，点确定</p><p><img src="https://img-blog.csdnimg.cn/20210512162441459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>创建数据库成功</p><p><img src="https://img-blog.csdnimg.cn/20210512162828442.png"></p><h1 id="新建表"><a href="#新建表" class="headerlink" title="新建表"></a>新建表</h1><p>my-表-右键-新建表</p><p><img src="https://img-blog.csdnimg.cn/2021051216301541.png"></p><p><img src="https://img-blog.csdnimg.cn/20210512163123811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>如上图所示，在第一个标签页“栏位”中</p><p>名：字段的名字</p><p>类型：字段的类型，有几十种，常用的有以下几种</p><ul><li>char，可以存定长的字符串</li><li>varchar，可以存变长的字符串（定长和变长的区别在长度中介绍）</li><li>int，可以存-2^31 (-2,147,483,648) 到 2^31 - 1 (2,147,483,647) 之间的数字</li><li>datetime，可以存日期类型的数据</li></ul><p>长度：数据存的最大长度，对于不同的字段类型，长度表示的意义也不一样</p><ul><li>字段类型为char时，该长度表示存的最大长度，例如为100时，存的数据就算不超过100位，也会占用100位的存储空间</li><li>字段类型为varchar时，该长度表示存的最大长度，例如为100时，数据占用的空间会根据存的数据的长度来分配，数据越短占用的空间越少</li><li>字段类型为int时，该长度无意义，不管是输入0还是100都一样，因为int类型已经确定了范围了</li><li>段类型为datetime时，该长度表示秒后面的小数点位数，为0时可以保存为2021-05-27 00:00:00，为3时可以保存为2021-05-27 16:48:41.000</li></ul><p>小数点：默认就行，不用填，没什么用</p><p>不是null：默认为否，就是插入数据时可以不填，默认会插入null，表示什么也没有，连空字符串都不是，如果勾上了，查询数据时就必须填入该字段，不然会报错</p><p>不是null后面还有一个空白列，点击之后会出现一把钥匙<img src="https://img-blog.csdnimg.cn/20210512165829689.png">，这个是用来设置主键的，把一个字段设置为主键相当于这个字段是这个表中的唯一数据，就是不重复的数据，一般会用一个无意义的字段表示，如id</p><p>下方区域：选择不同的字段类型会加载不同的内容，这里简单说几种</p><p>int：主要关注自动递增，如果勾上了，则插入数据时不用插入id字段，数据库会每次加1的插入到表中，其他选项不用理会</p><p><img src="https://img-blog.csdnimg.cn/20210512170427192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>varchar：默认中有三个选项，当插入数据时不插入该字段时，数据库会根据这项自动插入数据：选择第一个时可以编辑这个输入框，插入自定义的数据；选择第二个时会插入null（非字符串null，就是表示什么都没）；选择第三个时会插入空字符串。其他的选项一般不用管，保存表时会字段填入默认值。</p><p><img src="https://img-blog.csdnimg.cn/20210512170709937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>不管是什么字段类型，下面都会有注释输入框，就是填入该字段代表的意义，这个虽然可以不填，但是要养成一个良好的习惯就必须填。这里我要说一下，一个字段要选择什么样的类型没什么规定，主要看工作中公司怎么要求的，例如A公司要求年龄用int，性别用char，时间用datetime，B公司要求所有字段都用varchar。我在接下来的教程里会把字段类型全部设置成varchar，这点不用纠结为啥了。</p><p>接下来，我建一个用户表，搞一些用户的常用字段，字段名的定义一般用英文或者拼音全拼，可以用下划线分割，怎么定义也得看公司怎么要求的，有些公司说用拼音不专业，就非得用英文，这就很扯蛋了，只要通俗易懂就行了，用拼音需要避免用首字母，例如用户名称搞了个yhmc，鬼知道这个字段是啥意思，只要不大小写混用，不英文拼音混用就行了。</p><p><img src="https://img-blog.csdnimg.cn/20210512174059960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><h3 id="注意我以后所说的“保存”都不是点界面能上的保存按钮，都是用快捷键Ctrl-S操作的，这个与直接点击保存按钮效果是相同的，只是更方便"><a href="#注意我以后所说的“保存”都不是点界面能上的保存按钮，都是用快捷键Ctrl-S操作的，这个与直接点击保存按钮效果是相同的，只是更方便" class="headerlink" title="注意我以后所说的“保存”都不是点界面能上的保存按钮，都是用快捷键Ctrl+S操作的，这个与直接点击保存按钮效果是相同的，只是更方便"></a>注意我以后所说的“保存”都不是点界面能上的保存按钮，都是用快捷键Ctrl+S操作的，这个与直接点击保存按钮效果是相同的，只是更方便</h3><p>如上图，保存，然后弹出一个输入表名的框，输入完点确定就行了，如果点确定报错，检查下是不是类型输入错了或者别的原因，有时候建表时明明什么都对的保存时也会报错，这就是Navicat的bug了，关掉重新建表或者先建一个字段的表保存完再修改表结构加字段也行。</p><p><img src="https://img-blog.csdnimg.cn/20210512174539924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20210512175248503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>你可以双击打开表之后手动新增、修改、删除数据</p><p><img src="https://img-blog.csdnimg.cn/20210512180008518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>以上菜单里的选项建议都用一下，试试功能，下一节讲表的增删改查。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;关于mysql介绍网上一搜一大堆，这里就不再介绍了，我之后的mysql文章只讲最简单基础的用法，主要是为java程序服务的。如果有兴趣多学一点mysql的话，建议去&lt;a href=&quot;https://www.runoob.co</summary>
      
    
    
    
    <category term="Java" scheme="http://website13.github.io/categories/Java/"/>
    
    
    <category term="mysql教程 java教程 java入门教程 mysql建表 mysql创建数据库" scheme="http://website13.github.io/tags/mysql%E6%95%99%E7%A8%8B-java%E6%95%99%E7%A8%8B-java%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-mysql%E5%BB%BA%E8%A1%A8-mysql%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java入门教程：（十五）安装mysql</title>
    <link href="http://website13.github.io/2021/05/12/JAVA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%9A%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%AE%89%E8%A3%85mysql/"/>
    <id>http://website13.github.io/2021/05/12/JAVA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%9A%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E5%AE%89%E8%A3%85mysql/</id>
    <published>2021-05-12T07:30:46.000Z</published>
    <updated>2022-07-31T10:21:25.681Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>安装mysql之前需要下载两个安装包，我放到百度网盘了，最好用我提供的安装包保证一次性成功，如果自己下载最新的安装包，可能安装不顺利，导致没法继续了。没百度网盘会员的下载会贼慢，建议借一个会员账号来下载</p><p><img src="https://img-blog.csdnimg.cn/20210512115750617.png"></p><p>链接：<a href="https://pan.baidu.com/s/11BB9KBqeeVb9UxLa-Y97nQ">https://pan.baidu.com/s/11BB9KBqeeVb9UxLa-Y97nQ</a> <br>提取码：1234</p><p><img src="https://img-blog.csdnimg.cn/20210512144144247.png"></p><p>链接：<a href="https://pan.baidu.com/s/19BUDV2b8EsPHxOm04rChmA">https://pan.baidu.com/s/19BUDV2b8EsPHxOm04rChmA</a> <br>提取码：1234</p><h1 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h1><p>我们先安装mysql-installer-community-5.6.44.0.msi，步骤如下图</p><p>第1步：</p><p><img src="https://img-blog.csdnimg.cn/20210512135206389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>第2步：</p><p><img src="https://img-blog.csdnimg.cn/20210512135206399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>第3步：注意先点Execute，安装完所需的插件之后，Execute会消失，这时候再点Next。安装插件的时候会有几次英文或者中文的弹窗，勾选同意之后点安装就行了。</p><p><img src="https://img-blog.csdnimg.cn/20210512135206350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>第4步：</p><p><img src="https://img-blog.csdnimg.cn/20210512135206351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>第5步：</p><p><img src="https://img-blog.csdnimg.cn/20210512135206283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>第6步：</p><p><img src="https://img-blog.csdnimg.cn/2021051213520678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>第7步：</p><p><img src="https://img-blog.csdnimg.cn/20210512135206348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>第8步：mysql默认管理员账号是root，直接设置一个root密码即可，这个密码要记住。最下面创建一般用户账号的不用管</p><p><img src="https://img-blog.csdnimg.cn/20210512135206326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>第9步：</p><p><img src="https://img-blog.csdnimg.cn/20210512135645681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>第10步：</p><p> </p><p><img src="https://img-blog.csdnimg.cn/20210512135206281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>第11步：</p><p><img src="https://img-blog.csdnimg.cn/2021051213520680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>第12步：</p><p><img src="https://img-blog.csdnimg.cn/20210512135206250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>第13步：Check按钮是用来校验你之前设置的root密码是否正确</p><p><img src="https://img-blog.csdnimg.cn/20210512135206343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>第14步：</p><p><img src="https://img-blog.csdnimg.cn/20210512135206193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>第15步：</p><p><img src="https://img-blog.csdnimg.cn/2021051213520617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>第16步：</p><p><img src="https://img-blog.csdnimg.cn/20210512140157757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>第17步：</p><p><img src="https://img-blog.csdnimg.cn/2021051213520677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>安装完毕之后系统右下角托盘中会有一个mysql服务的图标，表示mysql服务已启动，并且默认的是开机自启，不需要自启的需要设置为手动</p><p><img src="https://img-blog.csdnimg.cn/20210512135205842.png"></p><p><img src="https://img-blog.csdnimg.cn/20210512140010137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><h1 id="安装Navicat"><a href="#安装Navicat" class="headerlink" title="安装Navicat"></a>安装Navicat</h1><p><img src="https://img-blog.csdnimg.cn/20210512141012415.png"></p><p>Navicat是一款可以连接数据库的软件，使用起来非常方便，我们可以用它创建数据库，创建表，查询数据，备份数据，导入&#x2F;导出数据等操作。</p><p><img src="https://img-blog.csdnimg.cn/20210512144238869.png"></p><p>安装时一直下一步就行了，安装完把PatchNavicat.exe复制到安装目录下运行即可激活软件，注意激活之前不要运行PatchNavicat，否则可能无法激活。如果激活失败，也不用管，点试用就行了。</p><h1 id="连接mysql"><a href="#连接mysql" class="headerlink" title="连接mysql"></a>连接mysql</h1><p>第1步：打开Navicat</p><p><img src="https://img-blog.csdnimg.cn/2021051214452555.png"></p><p>第2步：连接-MySQL</p><p><img src="https://img-blog.csdnimg.cn/20210512144633601.png"></p><p>第3步：</p><p>连接名：随便起一个</p><p>主机名或IP地址：默认localhost，表示本地电脑，填127.0.0.1也可以没啥区别</p><p>端口：默认3306</p><p>用户名：默认root</p><p>密码：填安装mysql时候设置的密码</p><p>填完之后点测试连接，提示连接成功表示可以，点确定就行了。</p><p><img src="https://img-blog.csdnimg.cn/20210512144726662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>第4步：双击新建的连接</p><p><img src="https://img-blog.csdnimg.cn/20210512145043421.png"></p><p>第5步：这里面显示的是mysql系统自带的数据库，我们可以点开查看里面的表，但是不要修改和删除里面的东西</p><p><img src="https://img-blog.csdnimg.cn/20210512145103118.png"></p><p>这个时候mysql默认只允许我们通过安装mysql的机器上直接连接，也就是说IP只能填localhost和127.0.0.1，如果填一个其他的IP就会连接失败，这也是出于安全考虑，如下图。</p><p>查看本地IP</p><p><img src="https://img-blog.csdnimg.cn/20210512145923493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>用本地IP192.168.32.129连接mysql就会报错</p><p><img src="https://img-blog.csdnimg.cn/20210512150035110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>我们一般都是在A机器上安装mysql，在其他机器上通过A的IP去连接mysql的，所有必须要设置一下mysql才能用过A机器的IP连接</p><p>sql：</p><p>Grant all privileges on *.* to ‘root’@‘%‘ identified by ‘12345’ with grant option;<br>flush privileges;</p><p>需要把12345换成你自己的root密码然后执行</p><p><img src="https://img-blog.csdnimg.cn/2021051215203081.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>如上图，点击完运行之后，会执行所有的sql，每一句sql用分号结束，然后我们在用本地ip连接数据库试试看</p><p><img src="https://img-blog.csdnimg.cn/20210512152537934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hqZ3pq,size_16,color_FFFFFF,t_70"></p><p>这样我们就能愉快的使用mysql了，另外再说一句，在使用数据时，出现任何问题和报错，把错误码或者关键信息放在百度上搜一下，一般都能获得答案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;安装mysql之前需要下载两个安装包，我放到百度网盘了，最好用我提供的安装包保证一次性成功，如果自己下载最新的安装包，可能安装不顺利，导致没法继续了。没百度网盘会员的下载会贼慢，建议借一个会员账号来下载&lt;/p&gt;
&lt;p&gt;&lt;im</summary>
      
    
    
    
    <category term="Java" scheme="http://website13.github.io/categories/Java/"/>
    
    
    <category term="mysql mysql教程 java教程 java入门 java入门教程" scheme="http://website13.github.io/tags/mysql-mysql%E6%95%99%E7%A8%8B-java%E6%95%99%E7%A8%8B-java%E5%85%A5%E9%97%A8-java%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java入门教程：（十四）小结</title>
    <link href="http://website13.github.io/2021/05/12/JAVA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%9A%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%B0%8F%E7%BB%93/"/>
    <id>http://website13.github.io/2021/05/12/JAVA%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%9A%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E5%B0%8F%E7%BB%93/</id>
    <published>2021-05-12T03:44:09.000Z</published>
    <updated>2022-07-31T10:21:27.335Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>文章陆陆续续搞了两年了，回头看了下之前写的内容，感觉虽然内容不太多，但是对于JAVA入门已经是够了，毕竟技术这个东西不是说所有的都靠学，很多时候是要在工作中去了解，用到什么再学什么。关于JAVA基础，其实还有很多内容没讲到，比如多线程、文件读写（I&#x2F;O）、网络编程等，这些东西还是以后用到了再说吧。实际工作中，只会JAVA是不行的，JAVA开发是需要多种语言&#x2F;工具配合使用的，我就想在接下来的文章中把开发中用到技术都简单讲解一下，这些技术虽然不是JAVA但是却是必须会的技能，我都把它归在JAVA技术里面。目前设想的内容有mysql和springboot技术，因为现在都是流行前后端分离了，所以就不再讲解前台技术了（css、js、html、vue这些都是前台技术）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;文章陆陆续续搞了两年了，回头看了下之前写的内容，感觉虽然内容不太多，但是对于JAVA入门已经是够了，毕竟技术这个东西不是说所有的都靠学，很多时候是要在工作中去了解，用到什么再学什么。关于JAVA基础，其实还有很多内容没讲到，</summary>
      
    
    
    
    <category term="Java" scheme="http://website13.github.io/categories/Java/"/>
    
    
    <category term="java教程 java入门 java开发教程 java入门教程" scheme="http://website13.github.io/tags/java%E6%95%99%E7%A8%8B-java%E5%85%A5%E9%97%A8-java%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B-java%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（24）——reflect.DeepEqual函数：判断两个值是否一致</title>
    <link href="http://website13.github.io/2020/08/28/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8824%EF%BC%89%E2%80%94%E2%80%94reflect.DeepEqual%E5%87%BD%E6%95%B0%EF%BC%9A%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%80%BC%E6%98%AF%E5%90%A6%E4%B8%80%E8%87%B4/"/>
    <id>http://website13.github.io/2020/08/28/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8824%EF%BC%89%E2%80%94%E2%80%94reflect.DeepEqual%E5%87%BD%E6%95%B0%EF%BC%9A%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%80%BC%E6%98%AF%E5%90%A6%E4%B8%80%E8%87%B4/</id>
    <published>2020-08-28T10:30:46.000Z</published>
    <updated>2022-07-31T09:22:36.783Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>对于<code>array</code>、<code>slice</code>、<code>map</code>、<code>struct</code>等类型，想要比较两个值是否相等，不能使用<code>==</code>，处理起来十分麻烦，在对效率没有太大要求的情况下，<code>reflect</code>包中的<code>DeepEqual</code>函数完美的解决了比较问题。</p><p>函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeepEqual</span><span class="params">(a1, a2 <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure><p>文档中对该函数的说明：<br><code>DeepEqual</code>函数用来判断两个值是否深度一致：除了类型相同；在可以时（主要是基本类型）会使用<code>==</code>；但还会比较<code>array</code>、<code>slice</code>的<strong>成员</strong>，<code>map</code>的<strong>键值对</strong>，<strong>结构体字段</strong>进行深入比对。<code>map</code>的键值对，对键只使用<code>==</code>，但值会继续往深层比对。<code>DeepEqual</code>函数可以正确处理循环的类型。函数类型只有都会<code>nil</code>时才相等；空切片不等于<code>nil</code>切片；还会考虑<code>array</code>、<code>slice</code>的长度、<code>map</code>键值对数。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m1 := <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="number">1</span>: []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, <span class="number">2</span>: <span class="number">3</span>, <span class="number">3</span>: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="number">1</span>: []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, <span class="number">2</span>: <span class="number">3</span>, <span class="number">3</span>: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line"><span class="keyword">if</span> reflect.DeepEqual(m1, m2) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;相等&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的输出是<code>相等</code>。例子中<code>map</code>的值类型是<code>interface&#123;&#125;</code>，如果自己处理去比较，还要使用<code>swich Type</code>来判断底层类型，十分麻烦。</p><p><a href="https://studygolang.com/pkgdoc">参考标准库中文文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;对于&lt;code&gt;array&lt;/code&gt;、&lt;code&gt;slice&lt;/code&gt;、&lt;code&gt;map&lt;/code&gt;、&lt;code&gt;struct&lt;/code&gt;等类型，想要比较两个值是否相等，不能使用&lt;code&gt;==&lt;/code&gt;，</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="go golang" scheme="http://website13.github.io/tags/go-golang/"/>
    
  </entry>
  
  <entry>
    <title>golang包的日常（5）——sync包：并发同步；sync/atomic包：原子级内存操作</title>
    <link href="http://website13.github.io/2020/08/26/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94sync%E5%8C%85%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%90%8C%E6%AD%A5%EF%BC%9Bsync!atomic%E5%8C%85%EF%BC%9A%E5%8E%9F%E5%AD%90%E7%BA%A7%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C/"/>
    <id>http://website13.github.io/2020/08/26/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94sync%E5%8C%85%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%90%8C%E6%AD%A5%EF%BC%9Bsync!atomic%E5%8C%85%EF%BC%9A%E5%8E%9F%E5%AD%90%E7%BA%A7%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C/</id>
    <published>2020-08-26T05:43:06.000Z</published>
    <updated>2022-07-31T09:22:26.860Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="package-sync"><a href="#package-sync" class="headerlink" title="package sync"></a>package sync</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br></pre></td></tr></table></figure><p><code>sync</code>包提供了基本的同步基元，如互斥锁。除了<code>Once</code>和<code>WaitGroup</code>类型，大部分都是适用于低水平程序线程，高水平的同步使用<code>channel</code>通信更好一些。</p><p>注意：本包的类型的值不应被拷贝。</p><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 包含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WaitGroup</code>用于等待一组线程的结束。父线程调用<code>Add</code>方法来设定应等待的线程的数量。每个被等待的线程在结束时应调用<code>Done</code>方法。同时，主线程里可以调用<code>Wait</code>方法阻塞至所有线程结束。<br><code>WaitGroup</code>对象内部有一个计数器，最初从<code>0</code>开始，它有三个方法：<code>Add</code>, <code>Done</code>, <code>Wait</code> 用来控制计数器的值：</p><ul><li><code>func (wg *WaitGroup) Add(delta int)</code>：<code>Add</code>方法向内部计数加上<code>delta</code>，<code>delta</code>可以是负数；如果内部计数器变为<code>0</code>，<code>Wait</code>方法阻塞等待的所有线程都会释放，如果计数器小于<code>0</code>，方法<code>panic</code>；</li><li><code>func (wg *WaitGroup) Done()</code>：<code>Done</code>方法使<code>WaitGroup</code>计数器的值减<code>1</code>，应在线程的最后执行；</li><li><code>func (wg *WaitGroup) Wait()</code>：<code>Wait</code>方法阻塞直到<code>WaitGroup</code>计数器减为<code>0</code>。</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Printf(<span class="string">&quot;我是f\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> f(&amp;wg)</span><br><span class="line">fmt.Println(<span class="string">&quot;我是main&quot;</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中<code>WaitGroup</code>对象可以阻塞<code>main</code>函数，直到所有<code>goroutine</code>都运行完毕。<br><code>WaitGroup</code>对象是结构体类型，传参时需要使用地址，否则进程会死锁；也可以直接声明全局变量。</p><h3 id="sync-Mutex：互斥锁"><a href="#sync-Mutex：互斥锁" class="headerlink" title="sync.Mutex：互斥锁"></a>sync.Mutex：互斥锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 包含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Mutex</code>是一个互斥锁，可以创建为其他结构体的字段；零值为解锁状态。<code>Mutex</code>类型的锁和线程无关，可以由不同的线程加锁和解锁。</p><p><code>Mutex</code>对象有两个方法：</p><ul><li><code>func (m *Mutex) Lock()</code>：<code>Lock</code>方法锁住<code>m</code>，如果<code>m</code>已经加锁，则阻塞直到<code>m</code>解锁；</li><li><code>func (m *Mutex) Unlock()</code>：<code>Unlock</code>方法解锁<code>m</code>，如果<code>m</code>未加锁会导致运行时错误。锁和线程无关，可以由不同的线程加锁和解锁。</li></ul><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个<code>goroutine</code>可以访问共享资源。</p><p>先举一个不加互斥锁的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int64</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">x = x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后会发现输出不是10000，而且无法预测。这是因为两个<code>goroutine</code>可能同时取到<code>x</code>，最后写入时相当于只进行了一次操作，导致结果出错。<br>对共享资源有修改操作时，可以使用互斥锁。在上例中加入互斥锁：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int64</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">lock.Lock()   <span class="comment">// 在访问共享资源前上锁</span></span><br><span class="line">x = x + <span class="number">1</span>     <span class="comment">// 上锁后其它goroutine无法访问x</span></span><br><span class="line">lock.Unlock() <span class="comment">// 访问完就解锁</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用互斥锁后输出正确结果10000。<br><code>Mutex</code>对象是结构体类型，如果不使用全局变量，那么传参时需要使用地址。</p><h3 id="sync-RWMutex：读写互斥锁"><a href="#sync-RWMutex：读写互斥锁" class="headerlink" title="sync.RWMutex：读写互斥锁"></a>sync.RWMutex：读写互斥锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 包含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RWMutex</code>是读写互斥锁。该锁可以被同时多个读取者持有或唯一个写入者持有。<code>RWMutex</code>可以创建为其他结构体的字段；零值为解锁状态。<code>RWMutex</code>类型的锁也和线程无关，可以由不同的线程加读取锁&#x2F;写入锁和解读取锁&#x2F;写入锁。<br>当一个<code>goroutine</code>获取读取锁之后，其他的<code>goroutine</code>如果是获取读取锁会继续获得锁，如果是获取写入锁就会等待；当一个<code>goroutine</code>获取写入锁之后，其他的<code>goroutine</code>无论是获取读取锁还是写入锁都会等待。</p><p><code>RWMutex</code>对象有 5 个方法：</p><ul><li><code>func (rw *RWMutex) Lock()</code>：<code>Lock</code>方法将<code>rw</code>锁定为写入状态，禁止其他线程读取或者写入；</li><li><code>func (rw *RWMutex) Unlock()</code>：<code>Unlock</code>方法解除<code>rw</code>的写入锁状态，如果<code>rw</code>未加写入锁会导致运行时错误；</li><li><code>func (rw *RWMutex) RLock()</code>：<code>RLock</code>方法将<code>rw</code>锁定为读取状态，禁止其他线程写入，但不禁止读取；</li><li><code>func (rw *RWMutex) RUnlock()</code>：<code>Runlock</code>方法解除<code>rw</code>的读取锁状态，如果<code>rw</code>未加读取锁会导致运行时错误；</li><li><code>func (rw *RWMutex) RLocker() Locker</code>：<code>Rlocker</code>方法返回一个互斥锁，通过调用<code>rw.Rlock</code>和<code>rw.Runlock</code>实现了<code>Locker</code>接口（该接口包含<code>Lock</code>和<code>Unlock</code>两个方法）。</li></ul><p>读写互斥锁的使用方式和互斥锁相同。对于<strong>读多写少</strong>的场景，如果使用互斥锁，那么共享资源始终只能被一个<code>goroutine</code>访问，而读写互斥锁可以让多个只读取共享资源的<code>goroutine</code>同时访问共享资源，这在读多写少场景中能大大节省时间。</p><h3 id="sync-Once：保证函数只执行一次"><a href="#sync-Once：保证函数只执行一次" class="headerlink" title="sync.Once：保证函数只执行一次"></a>sync.Once：保证函数只执行一次</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    done <span class="type">uint32</span> <span class="comment">// 表示函数是否已执行</span></span><br><span class="line">m    Mutex  <span class="comment">// 执行函数时需要上锁，保证只执行一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Once</code>是只执行一次动作的对象。只有一个方法<code>Do</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>)</span><br></pre></td></tr></table></figure><p><code>Do</code>方法当且仅当第一次被调用时才执行函数<code>f</code>。当<code>Once</code>对象已经调用<code>Do</code>方法后，即使更换<code>f</code>函数也不会再执行，所以不同的<code>f</code>函数需要声明不同的<code>Once</code>对象。<br>因为<code>f</code>是没有参数的，如果要执行的<code>f</code>需要传递参数就需要搭配<strong>闭包</strong>来使用，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; config.init(filename) &#125;)</span><br></pre></td></tr></table></figure><p>因为只有<code>f</code>返回后<code>Do</code>方法才会返回，所以<code>f</code>若引起了<code>Do</code>的调用，会导致死锁。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line">onceBody := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Only once&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        once.Do(onceBody)</span><br><span class="line">        done &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    &lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Only once</span><br></pre></td></tr></table></figure><p><code>sync.Once</code>内部包含的互斥锁能保证<code>f</code>的操作是<strong>并发安全</strong>的。</p><h3 id="sync-Map：并发安全的映射"><a href="#sync-Map：并发安全的映射" class="headerlink" title="sync.Map：并发安全的映射"></a>sync.Map：并发安全的映射</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 包含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Map</code>类似于Go <code>map[interface&#123;&#125;]interface&#123;&#125;</code>，但是可以安全地被多个<code>goroutine</code>并发使用，而无需额外的锁定或协调。 加载，存储和删除以分摊的常数时间运行。</p><p><code>Map</code>类型是专用的。 大部分代码应改用带有单独锁定或协调功能的普通map，以提高类型安全性，并使其更易于维护其他不变量以及映射内容。</p><p><code>Map</code>类型针对两种常见用例进行了优化：（1）一个键值对仅写入一次但读取多次，例如在仅增长的cache中；（2）多个goroutine进行读取，写入和覆盖不相交的键值对。在这两种情况下，与搭配单独的Mutex或RWMutex的Go map相比，使用Map可以显著减少锁竞争(Lock Contention)。</p><p><code>Map</code>对象无需初始化，声明后即可直接使用。</p><p><code>Map</code>对象目前有6个方法：</p><ul><li><code>func (m *Map) Delete(key interface&#123;&#125;)</code>：<code>Delete</code>方法删除<code>key</code>对应的值；</li><li><code>func (m *Map) Load(key interface&#123;&#125;) (value interface&#123;&#125;, ok bool)</code>：<code>Load</code>方法返回<code>key</code>对应的值，如果找不到则返回<code>nil</code>，<code>ok</code>表示是否找到值；</li><li><code>func (m *Map) LoadAndDelete(key interface&#123;&#125;) (value interface&#123;&#125;, loaded bool)</code>：<code>LoadAndDelete</code>方法1.15版本才有，其删除<code>key</code>对应的值并返回该值，<code>loaded</code>表示<code>key</code>是否存在；</li><li><code>func (m *Map) LoadOrStore(key, value interface&#123;&#125;) (actual interface&#123;&#125;, loaded bool)</code>：<code>LoadOrStore</code>方法，如果<code>key</code>存在则返回对应的值，如果不存在，则存储传入的<code>key</code>和<code>value</code>，返回传入的<code>value</code>，<code>loaded</code>为<code>true</code>表示载入(load)，为<code>false</code>表示存储(store)；</li><li><code>func (m *Map) Range(f func(key, value interface&#123;&#125;) bool)</code>：<code>Range</code>方法遍历<code>Map</code>对象，函数<code>f</code>接收参数<code>key</code>和<code>value</code>，返回一个<code>bool</code>值，返回<code>true</code>表示直接进行下一循环（接收下一对<code>key-value</code>），返回<code>false</code>表示结束循环（停止遍历）。遍历过程是<strong>无序</strong>的，与存储的顺序无关；</li><li><code>func (m *Map) Store(key, value interface&#123;&#125;)</code>：<code>Store</code>方法存储键值对。</li></ul><p><code>Range</code>方法示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 sync.Map</span><br><span class="line">m1.Store(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">m1.Store(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">m1.Store(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line"><span class="keyword">if</span> k == <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">m1.Range(f)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>因为遍历是无序的，所以输出只是其中一次输出，可以看到遍历到3就结束了。</p><h2 id="package-atomic"><a href="#package-atomic" class="headerlink" title="package atomic"></a>package atomic</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync/atomic&quot;</span></span><br></pre></td></tr></table></figure><p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法，它在用户态就可以完成，因此性能比加锁操作更好。</p><p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。</p><p>这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数&#x2F;类型实现同步更好。</p><p>应通过通信来共享内存，而不通过共享内存实现通信。</p><p><code>atomic</code>包提供的函数如下：</p><h3 id="读取系列"><a href="#读取系列" class="headerlink" title="读取系列"></a>读取系列</h3><p>原子性的获取<code>*addr</code>的值。</p><ul><li><code>func LoadInt32(addr *int32) (val int32)</code></li><li><code>func LoadInt64(addr *int64) (val int64)</code></li><li><code>func LoadUint32(addr *uint32) (val uint32)</code></li><li><code>func LoadUint64(addr *uint64) (val uint64)</code></li><li><code>func LoadUintptr(addr *uintptr) (val uintptr)</code></li><li><code>func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</code></li></ul><h3 id="写入系列"><a href="#写入系列" class="headerlink" title="写入系列"></a>写入系列</h3><p>原子性的将<code>val</code>的值保存到<code>*addr</code>。</p><ul><li><code>func StoreInt32(addr *int32, val int32)</code></li><li><code>func StoreInt64(addr *int64, val int64)</code></li><li><code>func StoreUint32(addr *uint32, val uint32)</code></li><li><code>func StoreUint64(addr *uint64, val uint64)</code></li><li><code>func StoreUintptr(addr *uintptr, val uintptr)</code></li><li><code>func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</code></li></ul><h3 id="修改系列（加减操作）"><a href="#修改系列（加减操作）" class="headerlink" title="修改系列（加减操作）"></a>修改系列（加减操作）</h3><p>原子性的将<code>delta</code>的值添加到<code>*addr</code>并返回新值。</p><ul><li><code>func AddInt32(addr *int32, delta int32) (new int32)</code></li><li><code>func AddInt64(addr *int64, delta int64) (new int64)</code></li><li><code>func AddUint32(addr *uint32, delta uint32) (new uint32)</code></li><li><code>func AddUint64(addr *uint64, delta uint64) (new uint64)</code></li><li><code>func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</code></li></ul><p>特别的，对于<code>AddUint32</code>和<code>AddUint64</code>，以<code>AddUint64</code>为例，如果要让<code>x</code>减去一个值<code>c</code>，调用<code>AddUint64(&amp;x, ^uint64(c-1))</code>；让<code>x</code>减1，调用<code>AddUint64(&amp;x, ^uint64(0))</code>。</p><h3 id="交换系列"><a href="#交换系列" class="headerlink" title="交换系列"></a>交换系列</h3><p>原子性的将<code>new</code>值保存到<code>*addr</code>并返回<code>*addr</code>原来的值。</p><ul><li><code>func SwapInt32(addr *int32, new int32) (old int32)</code></li><li><code>func SwapInt64(addr *int64, new int64) (old int64)</code></li><li><code>func SwapUint32(addr *uint32, new uint32) (old uint32)</code></li><li><code>func SwapUint64(addr *uint64, new uint64) (old uint64)</code></li><li><code>func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)</code></li><li><code>func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</code></li></ul><h3 id="比较并交换系列"><a href="#比较并交换系列" class="headerlink" title="比较并交换系列"></a>比较并交换系列</h3><p>原子性的比较<code>*addr</code>和<code>old</code>，如果相同则将<code>new</code>赋值给<code>*addr</code>并返回真。</p><ul><li><code>func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</code></li><li><code>func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)</code></li><li><code>func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)</code></li><li><code>func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)</code></li><li><code>func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)</code></li><li><code>func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</code></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://studygolang.com/pkgdoc">标准库中文文档</a><br><a href="https://godoc.org/sync">标准库英文文档&#x2F;sync包</a><br><a href="https://www.liwenzhou.com/posts/Go/14_concurrence/#autoid-1-7-4">博客1</a><br><a href="https://blog.csdn.net/jeffrey11223/article/details/79587015">博客2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;package-sync&quot;&gt;&lt;a href=&quot;#package-sync&quot; class=&quot;headerlink&quot; title=&quot;package sync&quot;&gt;&lt;/a&gt;package sync&lt;/h2&gt;&lt;figure </summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="go golang" scheme="http://website13.github.io/tags/go-golang/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（23）——并发之channel、select多路复用</title>
    <link href="http://website13.github.io/2020/08/19/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8823%EF%BC%89%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E4%B9%8Bchannel%E3%80%81select%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://website13.github.io/2020/08/19/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8823%EF%BC%89%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E4%B9%8Bchannel%E3%80%81select%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2020-08-19T09:08:09.000Z</published>
    <updated>2022-07-31T09:22:35.671Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="channel-通道"><a href="#channel-通道" class="headerlink" title="channel(通道)"></a>channel(通道)</h2><p><code>goroutine</code>和<code>channel</code>是 Go 语言秉承的 <code>CSP（Communicating Sequential Process）</code>并发模式的重要实现基础。该并发模式提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存实现通信</strong>。<br><code>channel</code>可以实现在多个<code>goroutine</code>之间进行通信，它是一种特殊的类型，遵循先入先出规则。每一个<code>channel</code>只能传递指定元素类型的数据。</p><h3 id="声明channel"><a href="#声明channel" class="headerlink" title="声明channel"></a>声明channel</h3><p><code>channel</code>是引用类型，声明<code>channel</code>的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 <span class="keyword">chan</span> 元素类型</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">bool</span> <span class="comment">// 声明一个传递布尔值的通道</span></span><br></pre></td></tr></table></figure><p>声明得到的通道的值是<code>nil</code>。</p><h3 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h3><p>通道使用<code>make</code>函数初始化，其格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> 元素类型, [缓冲大小])</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// 未设置缓冲大小，默认是0，所以ch1是无缓冲通道</span></span><br></pre></td></tr></table></figure><h3 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h3><p>使用之前创建的<code>ch1</code>。</p><ul><li>发送：<code>ch1 &lt;- 10</code>，把10发送到ch1中；</li><li>接收：<code>&lt;-ch1</code>，值可以用变量接收；</li><li>关闭：<code>close(ch)</code>，只有在所有数据都发送完毕的时候才需要关闭通道，但关闭通道不是必须的，其可以被垃圾回收机制回收。</li></ul><h3 id="已关闭通道的特点"><a href="#已关闭通道的特点" class="headerlink" title="已关闭通道的特点"></a>已关闭通道的特点</h3><ul><li>发送值会引发<code>panic</code>；</li><li>可以接收值直到通道为空，通道为空时继续接收会得到对应类型的零值；</li><li>再次关闭该通道会引发<code>panic</code>。</li></ul><h3 id="无缓冲通道"><a href="#无缓冲通道" class="headerlink" title="无缓冲通道"></a>无缓冲通道</h3><p>无缓冲的通道就是缓冲大小为0，因为没有缓冲，所以无缓冲通道在发送值的同时必须有一方在接收值，也就是说，接收值和发送值的操作需要在两个 <code>goroutine</code>中，否则程序就会因无限等待而死锁。</p><p>死锁示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fatal <span class="type">error</span>: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">chan</span> send]:</span><br><span class="line">main.main()</span><br><span class="line">e:/<span class="keyword">go</span>/src/github.com/BattleL/studygo/day07/<span class="number">04</span>channel/main.<span class="keyword">go</span>:<span class="number">20</span> +<span class="number">0x5b</span></span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure><p>启用一个<code>goroutine</code>解决死锁问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;-ch</span><br><span class="line">&#125;()</span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">&quot;发送成功&quot;</span>) <span class="comment">// 发送成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序正常运行。</p><h3 id="有缓冲通道"><a href="#有缓冲通道" class="headerlink" title="有缓冲通道"></a>有缓冲通道</h3><p>有缓冲通道，就是缓冲大小&gt;0，如果设置为3，那么该通道就最多能存放3个元素，存满就会阻塞，直到有元素被接收。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">&quot;发送成功&quot;</span>) <span class="comment">// 发送成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内置的<code>len</code>函数可以得到通道的元素数量，<code>cap</code>函数可以得到通道的容量。</p><h3 id="遍历通道"><a href="#遍历通道" class="headerlink" title="遍历通道"></a>遍历通道</h3><p>我们通常使用<code>for range</code>遍历通道，但要注意通道必须在发送完毕后关闭，否则会陷入死锁。<br>遍历方式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123;</span><br><span class="line"><span class="comment">// i就是接收的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断通道关闭"><a href="#判断通道关闭" class="headerlink" title="判断通道关闭"></a>判断通道关闭</h3><p>通道接收时可以有两个返回值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i, ok := &lt;-ch</span><br></pre></td></tr></table></figure><p>其中<code>i</code>是接收值，<code>ok</code>在接收成功时是<code>true</code>，在通道关闭且通道为空时是<code>false</code>。<br>可以利用<code>ok</code>，结合<code>for</code>循环实现通道遍历。</p><h3 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h3><p>当通道作为参数传递时，我们可能希望限制通道只能发送或只能接收，这就需要单向通道。<br>令<code>out</code>参数只能发送，<code>in</code>参数只能接收，函数名为<code>test</code>，无返回值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>, in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>chan&lt;- int</code>是int类型只写单向通道，只能发送不能接收；</li><li><code>&lt;-chan int</code>是int类型只读单向通道，只能接收不能发送。</li></ul><p>注意：双向通道可以转换为单向通道，但反过来不行。</p><h2 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h2><p><code>select</code>可以用于同时从多个通道随机接收数据，其类似于<code>switch</code>语句，有一系列<code>case</code>分支和一个默认的分支。每个<code>case</code>可以对应一个通道的接收&#x2F;发送操作。如果没有默认分支，<code>select</code>会一直等待，直到能够完成某个<code>case</code>的操作，如果多个分支都能完成，则随机选择一个。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">fmt.Println(x)</span><br><span class="line"><span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p>如果将例子中的通道容量设为2，那么就会出现两个分支同时满足的情况，因为分支选择的随机性，输出将无法预测。<br><code>select</code>的用途：</p><ul><li>提高代码可读性；</li><li>处理一个或多个通道的发送&#x2F;接收操作；</li><li>多个分支同时满足时会随机选择（如果自己遍历判断，则规定了执行顺序）；</li><li>没有分支的<code>select &#123;&#125;</code>会一直等待，可以用于阻塞<code>main</code>函数。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.liwenzhou.com/posts/Go/14_concurrence/#autoid-1-3-3">参考</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;channel-通道&quot;&gt;&lt;a href=&quot;#channel-通道&quot; class=&quot;headerlink&quot; title=&quot;channel(通道)&quot;&gt;&lt;/a&gt;channel(通道)&lt;/h2&gt;&lt;p&gt;&lt;code&gt;gorou</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go" scheme="http://website13.github.io/tags/golang-go/"/>
    
  </entry>
  
  <entry>
    <title>golang包的日常（4）——math/rand包：生成随机数</title>
    <link href="http://website13.github.io/2020/08/17/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94math!rand%E5%8C%85%EF%BC%9A%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <id>http://website13.github.io/2020/08/17/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94math!rand%E5%8C%85%EF%BC%9A%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</id>
    <published>2020-08-17T10:21:19.000Z</published>
    <updated>2022-07-31T09:22:25.310Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="package-rand"><a href="#package-rand" class="headerlink" title="package rand"></a>package rand</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/rand&quot;</span></span><br></pre></td></tr></table></figure><p><code>rand</code>包实现了伪随机数生成器。</p><h2 id="常用随机数生成方法"><a href="#常用随机数生成方法" class="headerlink" title="常用随机数生成方法"></a>常用随机数生成方法</h2><p>这里只介绍自己用到过的部分，更多函数&#x2F;方法请参考<a href="https://studygolang.com/pkgdoc">标准库文档中文版</a></p><h3 id="rand-Seed：设置随机数种子"><a href="#rand-Seed：设置随机数种子" class="headerlink" title="rand.Seed：设置随机数种子"></a>rand.Seed：设置随机数种子</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Seed</span><span class="params">(seed <span class="type">int64</span>)</span></span></span><br></pre></td></tr></table></figure><p>使用给定的<code>seed</code>将默认资源初始化到一个确定的状态；如未调用<code>Seed</code>，默认资源的行为就好像调用了<code>Seed(1)</code>。<br>如果程序每次运行，随机数种子都相同，那么使用随机数函数得到的随机数都是一样的，想让程序每次运行得到的随机数都不同，就需要让每次的随机数种子不相同。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano()) <span class="comment">// 取纳秒时间戳，可以保证每次的随机数种子都不同</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">fmt.Println(rand.Intn(<span class="number">1000</span>)) <span class="comment">// Intn(n)返回一个取值范围在[0,n)的伪随机int值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">357</span></span><br><span class="line"><span class="number">762</span></span><br><span class="line"><span class="number">182</span></span><br><span class="line"><span class="number">207</span></span><br><span class="line"><span class="number">646</span></span><br></pre></td></tr></table></figure><p>第二次输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">435</span></span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">673</span></span><br><span class="line"><span class="number">573</span></span><br><span class="line"><span class="number">491</span></span><br></pre></td></tr></table></figure><h3 id="rand-Int：生成非负伪随机int值"><a href="#rand-Int：生成非负伪随机int值" class="headerlink" title="rand.Int：生成非负伪随机int值"></a>rand.Int：生成非负伪随机int值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Int</span><span class="params">()</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure><p>返回一个非负的伪随机int值。</p><p>还有生成各种整型随机数的函数：</p><ul><li><code>func Int31() int32</code>：返回一个int32类型的非负的31位伪随机数；</li><li><code>func Int63() int64</code>：返回一个int64类型的非负的63位伪随机数；</li><li><code>func Uint32() uint32</code>：返回一个uint32类型的非负的32位伪随机数。</li></ul><h3 id="rand-Intn-n-：生成取值范围-0-n-的伪随机int值"><a href="#rand-Intn-n-：生成取值范围-0-n-的伪随机int值" class="headerlink" title="rand.Intn(n)：生成取值范围[0, n)的伪随机int值"></a>rand.Intn(n)：生成取值范围[0, n)的伪随机int值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Intn</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure><p>返回一个取值范围在[0,n)的伪随机int值，如果n&lt;&#x3D;0会panic。</p><p>还有生成各种整型范围随机数的函数：</p><ul><li><code>func Int31n(n int32) int32</code>：返回一个取值范围在[0,n)的伪随机int32值，如果n&lt;&#x3D;0会panic；</li><li><code>func Int63n(n int64) int64</code>：返回一个取值范围在[0, n)的伪随机int64值，如果n&lt;&#x3D;0会panic。</li></ul><h3 id="rand-Float32：生成取值范围-0-0-1-0-的伪随机float32值"><a href="#rand-Float32：生成取值范围-0-0-1-0-的伪随机float32值" class="headerlink" title="rand.Float32：生成取值范围[0.0, 1.0)的伪随机float32值"></a>rand.Float32：生成取值范围[0.0, 1.0)的伪随机float32值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float32</span><span class="params">()</span></span> <span class="type">float32</span></span><br></pre></td></tr></table></figure><p>返回一个取值范围在[0.0, 1.0)的伪随机float32值。</p><p>还有生成float64值的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64</span><span class="params">()</span></span> <span class="type">float64</span></span><br></pre></td></tr></table></figure><p>返回一个取值范围在[0.0, 1.0)的伪随机float64值。</p><h3 id="NormFloat64：标准正态分布"><a href="#NormFloat64：标准正态分布" class="headerlink" title="NormFloat64：标准正态分布"></a>NormFloat64：标准正态分布</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NormFloat64</span><span class="params">()</span></span> <span class="type">float64</span></span><br></pre></td></tr></table></figure><p>返回一个服从标准正态分布（标准差&#x3D;1，期望&#x3D;0）、取值范围在<code>[-math.MaxFloat64, +math.MaxFloat64]</code>的<code>float64</code>值。</p><p>如果要生成不同的正态分布值，调用者可用如下代码调整输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sample = NormFloat64() * 标准差 + 期望</span><br></pre></td></tr></table></figure><h3 id="ExpFloat64：标准指数分布"><a href="#ExpFloat64：标准指数分布" class="headerlink" title="ExpFloat64：标准指数分布"></a>ExpFloat64：标准指数分布</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExpFloat64</span><span class="params">()</span></span> <span class="type">float64</span></span><br></pre></td></tr></table></figure><p>返回一个服从标准指数分布（率参数&#x3D;1，率参数是期望的倒数）、取值范围在<code>(0, +math.MaxFloat64]</code>的<code>float64</code>值。</p><p>如要生成不同的指数分布值，调用者可用如下代码调整输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sample = ExpFloat64() / 率参数</span><br></pre></td></tr></table></figure><h3 id="Perm：生成随机排列的整数切片"><a href="#Perm：生成随机排列的整数切片" class="headerlink" title="Perm：生成随机排列的整数切片"></a>Perm：生成随机排列的整数切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Perm</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">int</span></span><br></pre></td></tr></table></figure><p>返回一个有n个元素的，[0,n)范围内整数的伪随机排列的切片。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(rand.Perm(<span class="number">10</span>)) <span class="comment">// [3 7 0 1 9 2 4 5 6 8]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;package-rand&quot;&gt;&lt;a href=&quot;#package-rand&quot; class=&quot;headerlink&quot; title=&quot;package rand&quot;&gt;&lt;/a&gt;package rand&lt;/h2&gt;&lt;figure </summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="go golang random" scheme="http://website13.github.io/tags/go-golang-random/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（22）——并发之goroutine：使用方式、sync.WaitGroup</title>
    <link href="http://website13.github.io/2020/08/17/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8822%EF%BC%89%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E4%B9%8Bgoroutine%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E3%80%81sync.WaitGroup/"/>
    <id>http://website13.github.io/2020/08/17/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8822%EF%BC%89%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E4%B9%8Bgoroutine%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E3%80%81sync.WaitGroup/</id>
    <published>2020-08-17T09:30:54.000Z</published>
    <updated>2022-07-31T09:22:34.614Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><p>Go语言的并发通过<code>goroutine</code>实现，其概念类似于线程，属于用户态的线程，我们可以创建很多个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go的运行时(<code>runtime</code>)来调度和管理的。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>启动<code>goroutine</code>只需要在调用的函数前加上<code>go</code>关键字，函数可以是普通函数也可以是匿名函数。<br>在程序启动时，Go程序会为<code>main()</code>函数创建一个默认的<code>goroutine</code>。它会在<code>main()</code>函数返回的时候结束，此时所有在<code>main()</code>函数中启动的<code>goroutine</code>不管有没有运行完都会一同结束。<br>如下例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;我是f1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> f1()</span><br><span class="line">fmt.Println(<span class="string">&quot;我是main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我是main</span><br></pre></td></tr></table></figure><p>可以发现，函数<code>f1</code>并没有打印结果，这是因为<code>goroutine</code>启动需要一定的时间，而例子中的<code>main()</code>函数早就结束了，在其中启动的<code>goroutine</code>也随之结束。<br>再看下例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;我是f1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> f1()</span><br><span class="line">fmt.Println(<span class="string">&quot;我是main&quot;</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是main</span><br><span class="line">我是f1</span><br></pre></td></tr></table></figure><p>我们让<code>main()</code>函数简单的睡眠1秒钟，让<code>goroutine</code>有时间执行完。因为<code>goroutine</code>启动需要时间，所以这里<code>&quot;我是main&quot;</code>先输出。</p><h2 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h2><p>当我们启动多个<code>goroutine</code>时，我们难以确定要让<code>main()</code>函数睡眠多久，这时我们可以使用<code>sync.WaitGroup</code>来实现<code>goroutine</code>的同步。</p><h3 id="sync-WaitGroup介绍"><a href="#sync-WaitGroup介绍" class="headerlink" title="sync.WaitGroup介绍"></a>sync.WaitGroup介绍</h3><p><code>WaitGroup</code> 对象内部有一个计数器，最初从<code>0</code>开始，它有三个方法：<code>Add()</code>, <code>Done()</code>, <code>Wait()</code> 用来控制计数器的数量。<code>Add(n)</code> 每次让计数器<code>+n</code>，<code>n</code>不能让计数器为负，否则会引发<code>panic</code>；<code>Done()</code> 每次让计数器<code>-1</code> ，<code>wait()</code> 会阻塞代码的运行，直到计数器的值为<code>0</code>。<br><code>WaitGroup</code> 对象是结构体类型，传参时需要使用地址，否则进程会死锁。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Printf(<span class="string">&quot;我是f%d\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> f(i, &amp;wg)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;我是main&quot;</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我是f8</span><br><span class="line">我是f3</span><br><span class="line">我是f9</span><br><span class="line">我是f5</span><br><span class="line">我是f6</span><br><span class="line">我是f7</span><br><span class="line">我是f1</span><br><span class="line">我是f0</span><br><span class="line">我是f2</span><br><span class="line">我是main</span><br><span class="line">我是f4</span><br></pre></td></tr></table></figure><p>每次的输出顺序都可能不同，因为并发执行时<code>goroutine</code>的调度是随机的。</p><h3 id="设置程序占用的最大逻辑核心数"><a href="#设置程序占用的最大逻辑核心数" class="headerlink" title="设置程序占用的最大逻辑核心数"></a>设置程序占用的最大逻辑核心数</h3><p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数，Go1.5版本后默认为当前机器的CPU逻辑核心数。<br>使用方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(<span class="number">4</span>) <span class="comment">// 将程序可占用的最大核心数设置为4个，最多4个任务并行</span></span><br></pre></td></tr></table></figure><p>通过<code>runtime.NumCPU()</code>函数可以获取当前机器的CPU逻辑核心数。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.liwenzhou.com/posts/Go/14_concurrence/#autoid-1-1-0">参考1</a>：一些概念：goroutine与线程的关系<br><a href="https://studygolang.com/articles/12972?fr=sidebar">参考2</a>：关于sync.WaitGroup的用法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;goroutine&quot;&gt;&lt;a href=&quot;#goroutine&quot; class=&quot;headerlink&quot; title=&quot;goroutine&quot;&gt;&lt;/a&gt;goroutine&lt;/h1&gt;&lt;p&gt;Go语言的并发通过&lt;code&gt;go</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go 多线程" scheme="http://website13.github.io/tags/golang-go-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>golang包的日常（3）——strconv包：基本数据类型和其字符串表示的相互转换</title>
    <link href="http://website13.github.io/2020/08/16/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94strconv%E5%8C%85%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%85%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E7%A4%BA%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"/>
    <id>http://website13.github.io/2020/08/16/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94strconv%E5%8C%85%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%85%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E7%A4%BA%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-08-16T09:30:33.000Z</published>
    <updated>2022-07-31T09:22:24.463Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="package-strconv"><a href="#package-strconv" class="headerlink" title="package strconv"></a>package strconv</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br></pre></td></tr></table></figure><p><code>strconv</code>包实现了基本数据类型和其字符串表示的相互转换。</p><p>下面介绍比较常用的转换函数，更多内容参考<a href="https://studygolang.com/pkgdoc">标准库文档中文版</a></p><h2 id="string与int互转"><a href="#string与int互转" class="headerlink" title="string与int互转"></a>string与int互转</h2><h3 id="ParseInt：字符串转int64"><a href="#ParseInt：字符串转int64" class="headerlink" title="ParseInt：字符串转int64"></a>ParseInt：字符串转int64</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="type">string</span>, base <span class="type">int</span>, bitSize <span class="type">int</span>)</span></span> (i <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>返回字符串表示的整数值，接受正负号。<br><code>base</code>指定进制（2到36），如果<code>base</code>为<code>0</code>，则会从字符串前置判断，<code>&quot;0x&quot;</code>是<code>16</code>进制，<code>&quot;0&quot;</code>是<code>8</code>进制，否则是<code>10</code>进制；<br><code>bitSize</code>指定结果必须能无溢出赋值的整数类型，<code>0</code>、<code>8</code>、<code>16</code>、<code>32</code>、<code>64</code> 分别代表 <code>int</code>、<code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code>；返回的<code>err</code>是<code>*NumErr</code>类型的，如果语法有误，<code>err.Error = ErrSyntax</code>；如果结果超出类型范围<code>err.Error = ErrRange</code>。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int32</span></span><br><span class="line">s := <span class="string">&quot;1111&quot;</span></span><br><span class="line">v, err := strconv.ParseInt(s, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">a = <span class="type">int32</span>(v)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, a) <span class="comment">// 1111</span></span><br></pre></td></tr></table></figure><p>例子中选择<code>10</code>进制，<code>bitSize</code>指定<code>64</code>能最大程度的保证赋值无溢出，因为返回值是<code>int64</code>类型，而<code>a</code>是<code>int32</code>类型，所以需要强制转换。</p><h3 id="Atoi：ParseInt-s-10-0-的简写"><a href="#Atoi：ParseInt-s-10-0-的简写" class="headerlink" title="Atoi：ParseInt(s, 10, 0)的简写"></a>Atoi：ParseInt(s, 10, 0)的简写</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atoi</span><span class="params">(s <span class="type">string</span>)</span></span> (i <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><h3 id="ParseUint：字符串转无符号整型"><a href="#ParseUint：字符串转无符号整型" class="headerlink" title="ParseUint：字符串转无符号整型"></a>ParseUint：字符串转无符号整型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseUint</span><span class="params">(s <span class="type">string</span>, base <span class="type">int</span>, bitSize <span class="type">int</span>)</span></span> (n <span class="type">uint64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>ParseUint</code>类似<code>ParseInt</code>但不接受正负号，用于无符号整型。</p><h3 id="FormatInt：int64转指定进制的字符串"><a href="#FormatInt：int64转指定进制的字符串" class="headerlink" title="FormatInt：int64转指定进制的字符串"></a>FormatInt：int64转指定进制的字符串</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="type">int64</span>, base <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure><p>返回<code>i</code>的<code>base</code>进制的字符串表示。<code>base</code>必须在<code>2</code>到<code>36</code>之间，结果中会使用小写字母<code>&#39;a&#39;</code>到<code>&#39;z&#39;</code>表示大于<code>10</code>的数字。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int32</span> = <span class="number">15</span></span><br><span class="line">s := strconv.FormatInt(<span class="type">int64</span>(a), <span class="number">2</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, s) <span class="comment">// “1111”</span></span><br></pre></td></tr></table></figure><p>其它整型类型需要强转到<code>int64</code>类型。例子中选择二进制。</p><h3 id="Itoa：FormatInt-i-10-的简写"><a href="#Itoa：FormatInt-i-10-的简写" class="headerlink" title="Itoa：FormatInt(i, 10) 的简写"></a>Itoa：FormatInt(i, 10) 的简写</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Itoa</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure><h3 id="FormatUint：int64转指定进制的字符串"><a href="#FormatUint：int64转指定进制的字符串" class="headerlink" title="FormatUint：int64转指定进制的字符串"></a>FormatUint：int64转指定进制的字符串</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatUint</span><span class="params">(i <span class="type">uint64</span>, base <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure><p>是FormatInt的无符号整数版本。</p><h2 id="string和float互转"><a href="#string和float互转" class="headerlink" title="string和float互转"></a>string和float互转</h2><h3 id="ParseFloat：字符串转float64"><a href="#ParseFloat：字符串转float64" class="headerlink" title="ParseFloat：字符串转float64"></a>ParseFloat：字符串转float64</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="type">string</span>, bitSize <span class="type">int</span>)</span></span> (f <span class="type">float64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>解析一个表示浮点数的字符串并返回其值。<br>如果<code>s</code>合乎语法规则，函数会返回最为接近<code>s</code>表示值的一个浮点数（使用IEEE754规范舍入）。<code>bitSize</code>指定了期望的接收类型，<code>32</code>是<code>float32</code>（返回值可以不改变精确值的赋值给float32），<code>64</code>是<code>float64</code>；返回值<code>err</code>是<code>*NumErr</code>类型的，语法有误的，<code>err.Error=ErrSyntax</code>；结果超出表示范围的，返回值<code>f</code>为<code>±Inf</code>，<code>err.Error= ErrRange</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">float32</span></span><br><span class="line">s := <span class="string">&quot;1111111.111&quot;</span></span><br><span class="line">v, err := strconv.ParseFloat(s, <span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">a = <span class="type">float32</span>(v)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, a) <span class="comment">// 1.1111111e+06</span></span><br></pre></td></tr></table></figure><p>注意返回值是<code>float64</code>类型，不能用<code>float32</code>类型的变量接收，需要强制转换。</p><h3 id="FormatFloat：浮点数转字符串"><a href="#FormatFloat：浮点数转字符串" class="headerlink" title="FormatFloat：浮点数转字符串"></a>FormatFloat：浮点数转字符串</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="type">float64</span>, fmt <span class="type">byte</span>, prec, bitSize <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure><p>函数将浮点数表示为字符串并返回。<br><code>bitSize</code>表示<code>f</code>的来源类型（32：float32、64：float64），会据此进行舍入。<br><code>fmt</code>表示格式：<code>&#39;f&#39;</code>（-ddd.dddd）、<code>&#39;b&#39;</code>（-ddddp±ddd，指数为二进制）、<code>&#39;e&#39;</code>（-d.dddde±dd，十进制指数）、<code>&#39;E&#39;</code>（-d.ddddE±dd，十进制指数）、<code>&#39;g&#39;</code>（指数很大时用’e’格式，否则’f’格式）、<code>&#39;G&#39;</code>（指数很大时用’E’格式，否则’f’格式）。<br><code>prec</code>控制精度（排除指数部分）：对’f’、‘e’、‘E’，它表示小数点后的数字个数；对’g’、‘G’，它控制总的数字个数。如果<code>prec</code> 为<code>-1</code>，则代表使用最少数量的、但又必需的数字来表示<code>f</code>。</p><h2 id="string和bool互转"><a href="#string和bool互转" class="headerlink" title="string和bool互转"></a>string和bool互转</h2><h3 id="ParseBool：字符串转bool"><a href="#ParseBool：字符串转bool" class="headerlink" title="ParseBool：字符串转bool"></a>ParseBool：字符串转bool</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(str <span class="type">string</span>)</span></span> (value <span class="type">bool</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>返回字符串表示的<code>bool</code>值。它接受<code>1</code>、<code>0</code>、<code>t</code>、<code>f</code>、<code>T</code>、<code>F</code>、<code>true</code>、<code>false</code>、<code>True</code>、<code>False</code>、<code>TRUE</code>、<code>FALSE</code>；否则返回错误。</p><h3 id="FormatBool：bool转字符串"><a href="#FormatBool：bool转字符串" class="headerlink" title="FormatBool：bool转字符串"></a>FormatBool：bool转字符串</h3><p>根据b的值返回”true”或”false”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;package-strconv&quot;&gt;&lt;a href=&quot;#package-strconv&quot; class=&quot;headerlink&quot; title=&quot;package strconv&quot;&gt;&lt;/a&gt;package strconv&lt;</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go" scheme="http://website13.github.io/tags/golang-go/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（21）——反射</title>
    <link href="http://website13.github.io/2020/08/14/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8821%EF%BC%89%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84/"/>
    <id>http://website13.github.io/2020/08/14/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8821%EF%BC%89%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84/</id>
    <published>2020-08-14T04:21:14.000Z</published>
    <updated>2022-07-31T09:22:33.484Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>反射是指在程序运行期间对程序本身进行访问和修改的能力。<br>反射的应用：当我们用空接口接收不同类型的结构体时，很难用类型断言去判断类型（因为自定义类型可以随意取名），这时就可以用到反射，来来得到结构体的类型，并进一步得到字段和对应值。<br>实际应用：<code>json</code>等数据解析（比如结构体博客中JSON序列化与反序列化）&#x2F;ORM等工具<br>注意：</p><ul><li>反射引起的<code>panic</code>在编译时不会产生，只有在运行时才能发现，所以代码比较脆弱</li><li>应用反射的代码通常难以理解</li><li>反射的性能更低<br>所以在写代码时要尽量避免使用反射，除非只能使用反射！（这也是我不想写细致内容的借口。。。以后用到再说。。。）</li></ul><p><code>reflect</code>包提供反射相关功能。</p><p>反射细致内容可以参考下面三个文档：</p><ol><li><a href="https://www.liwenzhou.com/posts/Go/13_reflect/">这篇博客</a>对于反射的各种函数和使用方式讲的比较细致</li><li><a href="https://www.jb51.net/article/154883.htm">这篇文章</a>从应用出发循序渐进，更容易理解反射</li><li><a href="https://studygolang.com/pkgdoc">标准库文档中文版</a>，实际写代码时，对于各种方法&#x2F;函数还是查文档更清晰一些，文档还推荐了一篇英文版的反射介绍</li></ol><h2 id="一些可能常用的方法"><a href="#一些可能常用的方法" class="headerlink" title="一些可能常用的方法"></a>一些可能常用的方法</h2><p>注意：所有值都默认用静态类型interface{}保存；只有用法，没有理由，具体可以查看参考中的标准库中文文档，或者代码实践。<br>该空接口类型变量名为<code>data</code></p><h3 id="判断data底层类型"><a href="#判断data底层类型" class="headerlink" title="判断data底层类型"></a>判断data底层类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断data的底层类型是否是指针类型</span></span><br><span class="line"><span class="keyword">if</span> reflect.TypeOf(data).Kind() != reflect.Ptr &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;data 不是指针类型&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>Kind</code>方法的返回值是<code>Kind</code>类型，<code>reflect</code>包中定义了很多<code>Kind</code>类型常量代表各种底层类型，<code>Ptr</code>就是其中一种。</p><h3 id="获得指针指向的值的底层类型"><a href="#获得指针指向的值的底层类型" class="headerlink" title="获得指针指向的值的底层类型"></a>获得指针指向的值的底层类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflect.TypeOf(data).Elem().Kind()</span><br></pre></td></tr></table></figure><p>其中<code>Elem</code>方法返回该类型的元素类型，如果该类型的<code>Kind</code>不是Array、Chan、Map(Map类型的元素是值)、Ptr或Slice，会<code>panic</code>。</p><h3 id="获得结构体字段数量"><a href="#获得结构体字段数量" class="headerlink" title="获得结构体字段数量"></a>获得结构体字段数量</h3><p>此时<code>data</code>的底层类型是结构体。如果底层类型是指针，可以使用前面的<code>Elem</code>方法得到其值类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := reflect.TypeOf(data)</span><br><span class="line">num := t.NumField() <span class="comment">// 此时num的值就是结构体字段数量</span></span><br></pre></td></tr></table></figure><p>其中<code>NumField</code>方法返回struct类型的字段数（匿名字段算作一个字段），如非结构体类型将<code>panic</code>。</p><h3 id="获得结构体第i个字段的类型"><a href="#获得结构体第i个字段的类型" class="headerlink" title="获得结构体第i个字段的类型"></a>获得结构体第i个字段的类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t := reflect.TypeOf(data)</span><br><span class="line">field := t.Field(<span class="number">0</span>) <span class="comment">// 返回的field是reflect.StructField类型</span></span><br><span class="line">fieldName := field.Name <span class="comment">// 得到字段名</span></span><br><span class="line">fieldType := field.Type <span class="comment">// 得到字段类型，返回值类型是reflect.Type</span></span><br><span class="line">fieldTag := field.Tag <span class="comment">// 得到字段的Tag，返回值类型是reflect.StructTag，该类型有Get(string) string方法，可以获得Tag中键对应的值</span></span><br></pre></td></tr></table></figure><p><code>Field</code>方法返回<code>struct</code>类型的第<code>i</code>个字段的类型，如非结构体或者<code>i</code>不在<code>[0, NumField())</code>内将会<code>panic</code>。<br><code>Field</code>方法一般和<code>NumField</code>方法在循环中使用。</p><h3 id="根据字段名得到结构体的字段类型"><a href="#根据字段名得到结构体的字段类型" class="headerlink" title="根据字段名得到结构体的字段类型"></a>根据字段名得到结构体的字段类型</h3><p>假设<code>structName</code>是字段名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t := reflect.TypeOf(data)</span><br><span class="line">structField, ok := t.FieldByName(structName)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;字段名不存在&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">structObjType := structField.Type <span class="comment">// 得到字段类型</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;反射是指在程序运行期间对程序本身进行访问和修改的能力。&lt;br&gt;反射的应用：当我们用空接口接收不同类型的结构体时，很难用类型断言去判断类型（因为自定义类型可以随意取名），这时就可以用到反射，来来得到结构体的类型，并进一步得到字</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="go golang" scheme="http://website13.github.io/tags/go-golang/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（20）——将格式化字符串作为函数参数</title>
    <link href="http://website13.github.io/2020/08/10/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8820%EF%BC%89%E2%80%94%E2%80%94%E5%B0%86%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"/>
    <id>http://website13.github.io/2020/08/10/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8820%EF%BC%89%E2%80%94%E2%80%94%E5%B0%86%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</id>
    <published>2020-08-10T09:22:01.000Z</published>
    <updated>2022-07-31T09:22:32.103Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>直接上简单实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatAsArgs</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">s := fmt.Sprintf(format, a...)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">name := <span class="string">&quot;小明&quot;</span></span><br><span class="line">id := <span class="number">10086</span></span><br><span class="line">formatAsArgs(<span class="string">&quot;name:%s, id:%d&quot;</span>, name, id) <span class="comment">// name:小明, id:10086</span></span><br><span class="line">formatAsArgs(<span class="string">&quot;name, id&quot;</span>) <span class="comment">// name, id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数<code>a ...interface&#123;&#125;</code>使得函数可以接收0个及以上的参数，使得函数既能接收普通字符串，也能接收格式化字符串。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;直接上简单实例：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go 字符串" scheme="http://website13.github.io/tags/golang-go-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（19）——runtime.Caller简单使用：获取函数名和对应的文件名、行号</title>
    <link href="http://website13.github.io/2020/08/10/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8819%EF%BC%89%E2%80%94%E2%80%94runtime.Caller%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E5%90%8D%E5%92%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D%E3%80%81%E8%A1%8C%E5%8F%B7/"/>
    <id>http://website13.github.io/2020/08/10/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8819%EF%BC%89%E2%80%94%E2%80%94runtime.Caller%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E5%90%8D%E5%92%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D%E3%80%81%E8%A1%8C%E5%8F%B7/</id>
    <published>2020-08-10T07:45:16.000Z</published>
    <updated>2022-07-31T09:22:30.134Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="runtime-Caller"><a href="#runtime-Caller" class="headerlink" title="runtime.Caller"></a>runtime.Caller</h2><p>函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Caller</span><span class="params">(skip <span class="type">int</span>)</span></span> (pc <span class="type">uintptr</span>, file <span class="type">string</span>, line <span class="type">int</span>, ok <span class="type">bool</span>)</span><br></pre></td></tr></table></figure><p><code>Caller</code>报告当前go程调用栈所执行的函数的文件和行号信息。实参<code>skip</code>为上溯的栈帧数，0表示<code>Caller</code>的调用者（<code>Caller</code>所在的调用栈）。函数的返回值为调用栈标识符、带路径的完整文件名、该调用在文件中的行号。如果无法获得信息，ok会被设为false。</p><h3 id="根据pc获取函数名"><a href="#根据pc获取函数名" class="headerlink" title="根据pc获取函数名"></a>根据pc获取函数名</h3><p>根据返回的调用栈标识符<code>pc</code>，我们可以获取对应的函数名。<br>需要用到一个函数和一个方法，签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncForPC</span><span class="params">(pc <span class="type">uintptr</span>)</span></span> *Func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Func)</span></span> Name</span><br></pre></td></tr></table></figure><p><code>FuncForPC</code>返回一个表示调用栈标识符<code>pc</code>对应的调用栈的<code>*Func</code>；如果该调用栈标识符没有对应的调用栈，函数会返回<code>nil</code>。每一个调用栈必然是对某个函数的调用。<br><code>Name</code>返回该调用栈所调用的函数的名字。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;path&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInfo</span><span class="params">(skip <span class="type">int</span>)</span></span> (funcName, fileName <span class="type">string</span>, lineNo <span class="type">int</span>) &#123;</span><br><span class="line">pc, file, lineNo, ok := runtime.Caller(skip)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;runtime.Caller() failed&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">funcName = runtime.FuncForPC(pc).Name()</span><br><span class="line">fileName = path.Base(file) <span class="comment">// Base函数返回路径的最后一个元素</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(getInfo(<span class="number">0</span>))</span><br><span class="line">fmt.Println(getInfo(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.getInfo main.<span class="keyword">go</span> <span class="number">10</span></span><br><span class="line">main.main main.<span class="keyword">go</span> <span class="number">22</span></span><br></pre></td></tr></table></figure><p>函数签名和函数作用均来自<a href="https://studygolang.com/pkgdoc">Go语言标准库文档中文版</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;runtime-Caller&quot;&gt;&lt;a href=&quot;#runtime-Caller&quot; class=&quot;headerlink&quot; title=&quot;runtime.Caller&quot;&gt;&lt;/a&gt;runtime.Caller&lt;/h2&gt;</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="go golang" scheme="http://website13.github.io/tags/go-golang/"/>
    
  </entry>
  
  <entry>
    <title>golang包的日常（2）——log包</title>
    <link href="http://website13.github.io/2020/08/09/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94log%E5%8C%85/"/>
    <id>http://website13.github.io/2020/08/09/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94log%E5%8C%85/</id>
    <published>2020-08-09T07:28:48.000Z</published>
    <updated>2022-07-31T09:22:23.559Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="普通使用"><a href="#普通使用" class="headerlink" title="普通使用"></a>普通使用</h2><p><code>log</code>包定义了<code>Logger</code>类型，该类型提供了一些格式化输出的方法。<br><code>log</code>包中预定义了一个标准<code>logger</code>对象<code>std</code>，使我们可以直接调用函数来打印日志，默认是标准错误输出（<code>Stderr</code>），打印到终端界面。当然也可以自定义创建<code>logger</code>对象，控制<code>std</code>所调用的所有函数在内部都是调用了同名的<code>logger</code>类型的方法。<br>函数包括：</p><ul><li><code>Print()</code>、<code>Printf()</code>、<code>Println()</code></li><li><code>Fatal()</code>、<code>Fatalf()</code>、<code>Fatalln()</code>：触发<code>fatal</code>，写入日志信息后调用<code>os.Exit(1)</code>，程序直接退出，不会调用defer</li><li><code>Panic</code>、<code>Panicf</code>、<code>Panicln</code>：触发<code>panic</code></li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log.Print(<span class="string">&quot;Print\n&quot;</span>)</span><br><span class="line">v := <span class="string">&quot;Printf&quot;</span></span><br><span class="line">log.Printf(<span class="string">&quot;%s\n&quot;</span>, v)</span><br><span class="line">log.Println(<span class="string">&quot;Println&quot;</span>)</span><br><span class="line">log.Fatalln(<span class="string">&quot;触发fatal&quot;</span>)</span><br><span class="line">log.Panicln(<span class="string">&quot;触发panic&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">13</span>:<span class="number">41</span>:<span class="number">18</span> Print</span><br><span class="line"><span class="number">2020</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">13</span>:<span class="number">41</span>:<span class="number">18</span> Printf</span><br><span class="line"><span class="number">2020</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">13</span>:<span class="number">41</span>:<span class="number">18</span> Println</span><br><span class="line"><span class="number">2020</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">13</span>:<span class="number">41</span>:<span class="number">18</span> 触发fatal</span><br></pre></td></tr></table></figure><p><code>log</code>包中预定义的<code>logger</code>对象默认会打印每条日志信息的日期、时间。例子中调用<code>Fatalln()</code>函数后，打印了日志信息，然后程序直接退出。</p><h2 id="配置logger"><a href="#配置logger" class="headerlink" title="配置logger"></a>配置logger</h2><p>当我们不满足于默认的日期和时间，就需要配置<code>logger</code>获得更多信息。<br><code>log</code>包中可以用<code>SetFlags()</code>函数来设置<code>std</code>的输出配置，然后可以用<code>Flags()</code>函数来返回<code>std</code>的输出配置。如果是自定义<code>logger</code>对象，也有同名方法可以使用，调用函数本质上是在内部用<code>std</code>调用同名方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Flags</span><span class="params">()</span></span> <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetFlags</span><span class="params">(flag <span class="type">int</span>)</span></span></span><br></pre></td></tr></table></figure><p><code>log</code>包为参数<code>flag</code>定义了一系列常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Ldate         = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>     <span class="comment">// the date in the local time zone: 2009/01/23</span></span><br><span class="line">Ltime                         <span class="comment">// the time in the local time zone: 01:23:23</span></span><br><span class="line">Lmicroseconds                 <span class="comment">// microsecond resolution: 01:23:23.123123.  assumes Ltime.</span></span><br><span class="line">Llongfile                     <span class="comment">// 文件全路径名 and line number: /a/b/c/d.go:23</span></span><br><span class="line">Lshortfile                    <span class="comment">// 文件名 and line number: d.go:23. 会覆盖Llongfile</span></span><br><span class="line">LUTC                          <span class="comment">// if Ldate or Ltime is set, use UTC rather than the local time zone</span></span><br><span class="line">Lmsgprefix                    <span class="comment">// move the &quot;prefix&quot; from the beginning of the line to before the message</span></span><br><span class="line">LstdFlags     = Ldate | Ltime <span class="comment">// initial values for the standard logger</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>LstdFlags</code>是标准<code>logger</code>对象<code>std</code>配置的初始值，下面是<code>std</code>的声明语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> std = New(os.Stderr, <span class="string">&quot;&quot;</span>, LstdFlags)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.SetFlags(log.Lshortfile | log.Lmicroseconds | log.Ldate)</span><br><span class="line">log.Println(<span class="string">&quot;配置之后的日志&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">14</span>:<span class="number">24</span>:<span class="number">52.532449</span> main.<span class="keyword">go</span>:<span class="number">17</span>: 配置之后的日志</span><br></pre></td></tr></table></figure><p>此时查看其输出配置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(log.Flags()) <span class="comment">// 13</span></span><br></pre></td></tr></table></figure><p>输出13是因为，<code>Llongfile</code>的值是<code>8</code>，<code>Lmicroseconds</code>的值是<code>4</code>，<code>Ldate</code>的值<code>1</code>，或运算后得到<code>13</code>。</p><h2 id="配置日志前缀"><a href="#配置日志前缀" class="headerlink" title="配置日志前缀"></a>配置日志前缀</h2><p>给输出的日志添加指定的前缀，有助于之后的信息检索。<br><code>log</code>包中可以用<code>SetPrefix()</code>函数来设置<code>std</code>的输出前缀，还可以用<code>Prefix()</code>函数查看<code>std</code>的输出前缀。如果是自定义<code>logger</code>对象，也有同名方法可以使用，调用函数本质上是在内部用<code>std</code>调用同名方法。</p><p>示例（<code>logger</code>配置接上例）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log.SetPrefix(<span class="string">&quot;[我是前缀]&quot;</span>)</span><br><span class="line">log.Println(<span class="string">&quot;带前缀的日志。&quot;</span>)</span><br><span class="line">fmt.Println(log.Prefix())</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[我是前缀]<span class="number">2020</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">05.437154</span> main.<span class="keyword">go</span>:<span class="number">20</span>: 带前缀的日志。</span><br><span class="line">[我是前缀]</span><br></pre></td></tr></table></figure><h2 id="配置日志输出位置"><a href="#配置日志输出位置" class="headerlink" title="配置日志输出位置"></a>配置日志输出位置</h2><p><code>log</code>包中可以用<code>SetOutput()</code>函数来设置<code>std</code>的输出目的地，默认是标准错误输出（<code>Stderr</code>）。如果是自定义<code>logger</code>对象，也有同名方法可以使用，调用函数本质上是在内部用<code>std</code>调用同名方法。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">logFile, err := os.OpenFile(<span class="string">&quot;t1.log&quot;</span>, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;open log file failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.SetOutput(logFile)</span><br><span class="line">log.SetFlags(log.Lshortfile | log.Lmicroseconds | log.Ldate)</span><br><span class="line">log.SetPrefix(<span class="string">&quot;[我是前缀]&quot;</span>)</span><br><span class="line">log.Println(<span class="string">&quot;我是日志。&quot;</span>)</span><br></pre></td></tr></table></figure><p>上例会将日志输出到同目录下的<code>t1.log</code>文件中。<br>文件中的输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[我是前缀]<span class="number">2020</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">15</span>:<span class="number">12</span>:<span class="number">25.340135</span> main.<span class="keyword">go</span>:<span class="number">31</span>: 我是日志。</span><br></pre></td></tr></table></figure><p>如果使用<code>std</code>，可以将配置操作写到<code>init()</code>函数中。</p><h2 id="自定义logger对象"><a href="#自定义logger对象" class="headerlink" title="自定义logger对象"></a>自定义logger对象</h2><p><code>log</code>包提供了<code>logger</code>对象的构造函数<code>New()</code>，格式如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(out io.Writer, prefix <span class="type">string</span>, flag <span class="type">int</span>)</span></span> *Logger</span><br></pre></td></tr></table></figure><p>参数依次是输出目的地、前缀、日志信息。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logger := log.New(os.Stderr, <span class="string">&quot;&lt;New&gt;&quot;</span>, log.Lshortfile|log.Ldate|log.Ltime)</span><br><span class="line">logger.Println(<span class="string">&quot;自定义logger日志。&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;New&gt;<span class="number">2020</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">17</span> main.<span class="keyword">go</span>:<span class="number">33</span>: 自定义logger日志。</span><br></pre></td></tr></table></figure><p><a href="https://www.liwenzhou.com/posts/Go/go_log/">参考</a><br><a href="https://github.com/sirupsen/logrus">第三方日志库logrus</a><br><a href="https://github.com/uber-go/zap">第三方日志库zap</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;普通使用&quot;&gt;&lt;a href=&quot;#普通使用&quot; class=&quot;headerlink&quot; title=&quot;普通使用&quot;&gt;&lt;/a&gt;普通使用&lt;/h2&gt;&lt;p&gt;&lt;code&gt;log&lt;/code&gt;包定义了&lt;code&gt;Logger&lt;/cod</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="go golang" scheme="http://website13.github.io/tags/go-golang/"/>
    
  </entry>
  
  <entry>
    <title>golang包的日常（1）——time包</title>
    <link href="http://website13.github.io/2020/08/08/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94time%E5%8C%85/"/>
    <id>http://website13.github.io/2020/08/08/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94time%E5%8C%85/</id>
    <published>2020-08-08T08:06:35.000Z</published>
    <updated>2022-07-31T09:22:22.488Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><p>时间类型：<code>time.Time</code><br>我们可以通过<code>time</code>包中的<code>Now</code>函数获取当前本地时间，然后使用时间类型的方法得到当前本地时间的年、月、日等信息。<br><code>Now()</code>函数格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// // Now returns the current local time.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Now</span><span class="params">()</span></span> Time</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)                     <span class="comment">// 2020-08-08 13:25:18.5419281 +0800 CST m=+0.001996701</span></span><br><span class="line">fmt.Println(<span class="string">&quot;年：&quot;</span>, now.Year())        <span class="comment">// 年： 2020</span></span><br><span class="line">fmt.Println(<span class="string">&quot;月：&quot;</span>, now.Month())       <span class="comment">// 月： August</span></span><br><span class="line">fmt.Println(<span class="string">&quot;日：&quot;</span>, now.Day())         <span class="comment">// 日： 8</span></span><br><span class="line">fmt.Println(<span class="string">&quot;小时：&quot;</span>, now.Hour())       <span class="comment">// 小时： 13</span></span><br><span class="line">fmt.Println(<span class="string">&quot;分钟：&quot;</span>, now.Minute())     <span class="comment">// 分钟： 25</span></span><br><span class="line">fmt.Println(<span class="string">&quot;秒：&quot;</span>, now.Second())      <span class="comment">// 秒： 18</span></span><br><span class="line">fmt.Println(<span class="string">&quot;纳秒：&quot;</span>, now.Nanosecond()) <span class="comment">// 纳秒： 541928100</span></span><br></pre></td></tr></table></figure><p>时间类型还有其它方法：<br><code>Date()</code>：返回年月日<br><code>Clock()</code>：返回时分秒<br>更多方法函数参考<a href="https://studygolang.com/pkgdoc">包文档中文版</a></p><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>时间戳是自1970年1月1日（08:00:00GMT）至当前时间的总毫秒数。它也被称为<code>Unix</code>时间戳（UnixTimestamp）。<br>获取时间戳：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">timestamp1 := now.Unix()     <span class="comment">//时间戳</span></span><br><span class="line">timestamp2 := now.UnixNano() <span class="comment">//纳秒时间戳</span></span><br><span class="line">fmt.Println(timestamp1, <span class="string">&quot;秒&quot;</span>)  <span class="comment">// 1596866180 秒</span></span><br><span class="line">fmt.Println(timestamp2, <span class="string">&quot;纳秒&quot;</span>) <span class="comment">// 1596866180018784800 纳秒</span></span><br></pre></td></tr></table></figure><p><code>time</code>包中的<code>Unix()</code>函数可以将时间戳转换为时间格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">timed := time.Unix(timestamp1, <span class="number">0</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;年：&quot;</span>, timed.Year())        <span class="comment">// 年： 2020</span></span><br><span class="line">fmt.Println(<span class="string">&quot;月：&quot;</span>, timed.Month())       <span class="comment">// 月： August</span></span><br><span class="line">fmt.Println(<span class="string">&quot;日：&quot;</span>, timed.Day())         <span class="comment">// 日： 8</span></span><br><span class="line">fmt.Println(<span class="string">&quot;小时：&quot;</span>, timed.Hour())       <span class="comment">// 小时： 14</span></span><br><span class="line">fmt.Println(<span class="string">&quot;分钟：&quot;</span>, timed.Minute())     <span class="comment">// 分钟： 7</span></span><br><span class="line">fmt.Println(<span class="string">&quot;秒：&quot;</span>, timed.Second())      <span class="comment">// 秒： 47</span></span><br><span class="line">fmt.Println(<span class="string">&quot;纳秒：&quot;</span>, timed.Nanosecond()) <span class="comment">// 纳秒： 0</span></span><br></pre></td></tr></table></figure><p>其中<code>Unix()</code>函数的格式是：<br><code>func Unix(sec int64, nsec int64) Time</code><br>其接收秒数和纳秒数，返回值是时间类型。</p><h2 id="时间间隔"><a href="#时间间隔" class="headerlink" title="时间间隔"></a>时间间隔</h2><p><code>time.Duration</code>是<code>time包</code>定义的一个类型（<code>type Duration int64</code>），它代表两个时间点之间经过的时间，以纳秒为单位。<br><code>time</code>包中定义了一些<code>Duration</code>类型的常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Nanosecond  Duration = <span class="number">1</span></span><br><span class="line">Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line">Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line">Second               = <span class="number">1000</span> * Millisecond</span><br><span class="line">Minute               = <span class="number">60</span> * Second</span><br><span class="line">Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(time.Second)      <span class="comment">// 1s</span></span><br><span class="line">fmt.Println(time.Microsecond) <span class="comment">// 1µs</span></span><br></pre></td></tr></table></figure><h2 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h2><h3 id="Add-方法"><a href="#Add-方法" class="headerlink" title="Add()方法"></a>Add()方法</h3><p>给当前时间增加一定的时间间隔，得到新的时间。如果传入的时间间隔是负的，则可以实现当前时间减去一定的时间间隔。<br>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add returns the time t+d.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Add(d Duration) Time</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now) <span class="comment">// 2020-08-08 14:34:46.3158009 +0800 CST m=+0.001981901</span></span><br><span class="line">later := now.Add(<span class="number">3</span>*time.Hour + time.Second) <span class="comment">// 当前时间增加3小时和1秒钟</span></span><br><span class="line">fmt.Println(later) <span class="comment">// 2020-08-08 17:34:47.3158009 +0800 CST m=+10801.001981901</span></span><br></pre></td></tr></table></figure><h3 id="Sub-方法"><a href="#Sub-方法" class="headerlink" title="Sub()方法"></a>Sub()方法</h3><p>返回两个时间的时间间隔。如果结果超出了时间间隔的范围，返回边界值。<br>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sub returns the duration t-u.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Sub(u Time) Duration</span><br></pre></td></tr></table></figure><p>示例（接上例）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">duration := later.Sub(now)</span><br><span class="line">fmt.Println(duration) <span class="comment">// 3h0m1s</span></span><br></pre></td></tr></table></figure><h3 id="Equal-方法"><a href="#Equal-方法" class="headerlink" title="Equal()方法"></a>Equal()方法</h3><p>判断两个时间是否相等，考虑时区的影响，例如，6:00 +0200和4:00 UTC相等。使用<code>==</code>比较两个时间不会考虑时区；大部分代码都会使用<code>Equal()</code>而不是<code>==</code>。<br>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Equal reports whether t and u represent the same time instant.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Equal(u Time) <span class="type">bool</span></span><br></pre></td></tr></table></figure><h3 id="Before-和After-方法"><a href="#Before-和After-方法" class="headerlink" title="Before()和After()方法"></a>Before()和After()方法</h3><p>判断时间先后。<br>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before reports whether the time instant t is before u.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Before(u Time) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// After reports whether the time instant t is after u.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> After(u Time) <span class="type">bool</span></span><br></pre></td></tr></table></figure><p>示例（接上例）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(later.Before(now)) <span class="comment">// false</span></span><br><span class="line">fmt.Println(later.After(now))  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>使用<code>time</code>包中的<code>Tick()</code>函数来设置定时器，定时器的本质上是一个通道（channel）。<br><code>Tick()</code>函数格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tick</span><span class="params">(d Duration)</span></span> &lt;-<span class="keyword">chan</span> Time</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ticker := time.Tick(time.Second) <span class="comment">//定义一个1秒间隔的定时器</span></span><br><span class="line"><span class="keyword">for</span> t := <span class="keyword">range</span> ticker &#123;</span><br><span class="line">fmt.Println(t) <span class="comment">//每秒都会执行的任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一定时间后部分输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-08</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">15.9648025</span> +<span class="number">0800</span> CST m=+<span class="number">1.012436201</span></span><br><span class="line"><span class="number">2020</span><span class="number">-08</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">16.9658258</span> +<span class="number">0800</span> CST m=+<span class="number">2.013459501</span></span><br><span class="line"><span class="number">2020</span><span class="number">-08</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">17.9650674</span> +<span class="number">0800</span> CST m=+<span class="number">3.012701101</span></span><br><span class="line"><span class="number">2020</span><span class="number">-08</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">18.9658949</span> +<span class="number">0800</span> CST m=+<span class="number">4.013528601</span></span><br><span class="line"><span class="number">2020</span><span class="number">-08</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">19.9660939</span> +<span class="number">0800</span> CST m=+<span class="number">5.013727601</span></span><br><span class="line"><span class="number">2020</span><span class="number">-08</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">20.9649029</span> +<span class="number">0800</span> CST m=+<span class="number">6.012536601</span></span><br><span class="line"><span class="number">2020</span><span class="number">-08</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">21.9653321</span> +<span class="number">0800</span> CST m=+<span class="number">7.012965801</span></span><br><span class="line"><span class="number">2020</span><span class="number">-08</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">22.9648979</span> +<span class="number">0800</span> CST m=+<span class="number">8.012531601</span></span><br><span class="line"><span class="number">2020</span><span class="number">-08</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">23.9646915</span> +<span class="number">0800</span> CST m=+<span class="number">9.012325201</span></span><br></pre></td></tr></table></figure><h2 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h2><p>时间类型有一个自带的方法<code>Format()</code>进行格式化，需要注意的是Go语言中格式化时间模板不是常见的<code>Y-m-d H:M:S</code>而是使用Go的诞生时间2006年1月2号15点04分05秒。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line"><span class="comment">// 24小时制</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006-01-02 15:04:05.000 Mon Jan&quot;</span>)) <span class="comment">// 2020-08-08 15:34:23.164 Sat Aug</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;Mon Jan 2006-01-02 15:04:05&quot;</span>)) <span class="comment">// Sat Aug 2020-08-08 15:34:23</span></span><br><span class="line"><span class="comment">// 12小时制，注意需要指定 PM</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006-01-02 03:04:05.000 PM&quot;</span>)) <span class="comment">// 2020-08-08 03:34:23.164 PM</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006/01/02 15:04&quot;</span>))           <span class="comment">// 2020/08/08 15:34</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;15:04 2006/01/02&quot;</span>))           <span class="comment">// 15:34 2020/08/08</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006/01/02&quot;</span>))                 <span class="comment">// 2020/08/08</span></span><br></pre></td></tr></table></figure><h3 id="解析格式化的时间"><a href="#解析格式化的时间" class="headerlink" title="解析格式化的时间"></a>解析格式化的时间</h3><p><code>time</code>包有两个函数可以解析字符串格式的时间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(layout, value <span class="type">string</span>)</span></span> (Time, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInLocation</span><span class="params">(layout, value <span class="type">string</span>, loc *Location)</span></span> (Time, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>Parse()</code>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> longForm = <span class="string">&quot;Jan 2, 2006 at 3:04pm (MST)&quot;</span></span><br><span class="line">t, _ := time.Parse(longForm, <span class="string">&quot;Feb 3, 2013 at 7:54pm (PST)&quot;</span>)</span><br><span class="line">fmt.Println(t) <span class="comment">// 2013-02-03 19:54:00 -0800 PST</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shortForm = <span class="string">&quot;2006-Jan-02&quot;</span></span><br><span class="line">t, _ = time.Parse(shortForm, <span class="string">&quot;2013-Feb-03&quot;</span>)</span><br><span class="line">fmt.Println(t) <span class="comment">// 2013-02-03 00:00:00 +0000 UTC</span></span><br></pre></td></tr></table></figure><p>对于<code>Parse()</code>函数，如果参数<code>value</code>带有时区信息，那么以<code>value</code>中的时区信息为准，否则默认时区是<code>UTC</code>。</p><p><code>ParseInLocation()</code>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">loc, _ := time.LoadLocation(<span class="string">&quot;Europe/Berlin&quot;</span>) <span class="comment">// 加载时区</span></span><br><span class="line"><span class="keyword">const</span> longForm = <span class="string">&quot;Jan 2, 2006 at 3:04pm (MST)&quot;</span></span><br><span class="line">t, _ := time.ParseInLocation(longForm, <span class="string">&quot;Jul 9, 2012 at 5:02am (CEST)&quot;</span>, loc)</span><br><span class="line">fmt.Println(t) <span class="comment">// 2012-07-09 05:02:00 +0200 CEST</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shortForm = <span class="string">&quot;2006-Jan-02&quot;</span></span><br><span class="line">t, _ = time.ParseInLocation(shortForm, <span class="string">&quot;2012-Jul-09&quot;</span>, loc)</span><br><span class="line">fmt.Println(t) <span class="comment">// 2012-07-09 00:00:00 +0200 CEST</span></span><br></pre></td></tr></table></figure><p>对于<code>ParseInLocation()</code>函数，时区以参数<code>loc</code>为准。</p><p><a href="https://www.liwenzhou.com/posts/Go/go_time/">参考1</a><br><a href="https://studygolang.com/pkgdoc">参考2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;时间类型&quot;&gt;&lt;a href=&quot;#时间类型&quot; class=&quot;headerlink&quot; title=&quot;时间类型&quot;&gt;&lt;/a&gt;时间类型&lt;/h2&gt;&lt;p&gt;时间类型：&lt;code&gt;time.Time&lt;/code&gt;&lt;br&gt;我们可以通过</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go" scheme="http://website13.github.io/tags/golang-go/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（18）——文件操作：文件开关、简单的读写实例、设置文件读写位置、文件删除、文件名重命名、文件操作相关方法/函数补充</title>
    <link href="http://website13.github.io/2020/08/07/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8818%EF%BC%89%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%EF%BC%9A%E6%96%87%E4%BB%B6%E5%BC%80%E5%85%B3%E3%80%81%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%BB%E5%86%99%E5%AE%9E%E4%BE%8B%E3%80%81%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E4%BD%8D%E7%BD%AE%E3%80%81%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E3%80%81%E6%96%87%E4%BB%B6%E5%90%8D%E9%87%8D%E5%91%BD%E5%90%8D%E3%80%81%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95!%E5%87%BD%E6%95%B0%E8%A1%A5%E5%85%85/"/>
    <id>http://website13.github.io/2020/08/07/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8818%EF%BC%89%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%EF%BC%9A%E6%96%87%E4%BB%B6%E5%BC%80%E5%85%B3%E3%80%81%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%BB%E5%86%99%E5%AE%9E%E4%BE%8B%E3%80%81%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E4%BD%8D%E7%BD%AE%E3%80%81%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E3%80%81%E6%96%87%E4%BB%B6%E5%90%8D%E9%87%8D%E5%91%BD%E5%90%8D%E3%80%81%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95!%E5%87%BD%E6%95%B0%E8%A1%A5%E5%85%85/</id>
    <published>2020-08-07T05:00:33.000Z</published>
    <updated>2022-07-31T09:22:28.869Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="文件打开和关闭"><a href="#文件打开和关闭" class="headerlink" title="文件打开和关闭"></a>文件打开和关闭</h2><p><code>os</code>包中<code>Open</code>函数能够以只读方式打开一个文件，函数返回<code>*File</code>和<code>err</code>。打开的文件可以通过调用<code>Close</code>方法关闭。<br><code>Open</code>函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="type">string</span>)</span></span> (*File, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>Open</code>函数接收文件路径，返回一个文件指针和可能的具体错误。<br><code>Close</code>方法签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *File)</span></span> Close() <span class="type">error</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;open file failed!, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭文件，配合defer能防止忘记关闭</span></span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><h3 id="Read方法"><a href="#Read方法" class="headerlink" title="Read方法"></a>Read方法</h3><p>签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>Read</code>方法接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回<code>0</code>和<code>io.EOF</code>（需要导入<code>io</code>包）。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">file, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;open file failed!, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="comment">// 循环读取文件</span></span><br><span class="line"><span class="keyword">var</span> content []<span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">128</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := file.Read(tmp)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;read file failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">content = <span class="built_in">append</span>(content, tmp[:n]...)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bufio按行读取"><a href="#bufio按行读取" class="headerlink" title="bufio按行读取"></a>bufio按行读取</h3><p>需要导入<code>bufio</code>包。<br>按行读取示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;open file failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="comment">// 新建一个缓冲区，把内容先放在缓冲区</span></span><br><span class="line">reader := bufio.NewReader(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 遇到&#x27;\n&#x27;则结束读取，读取内容包括&#x27;\n&#x27;</span></span><br><span class="line">line, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 注意是字符</span></span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(line) != <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(line)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;read file failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(line)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中用到了<code>bufio</code>包中的一个函数和一个方法。<br><code>NewReader</code>函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span></span> *Reader</span><br></pre></td></tr></table></figure><p><code>NewReader</code>函数会新建一个默认大小的缓冲区，把文件内容先放在缓冲区，返回该缓冲区指针。其参数是一个接口，当接收文件指针时，可以读取文件内容；当接收<code>io.Stdin</code>时，从标准输入生成读对象。</p><p><code>ReadString()</code>方法签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> ReadString(delim <span class="type">byte</span>) (<span class="type">string</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>ReadString</code>方法接收的是一个字符，每次读取到这个字符为止，包括该字符。所以当传入<code>\n</code>时，就可以实现一次读取一行。其返回值是读取的字符串和可能的具体错误。</p><h3 id="ioutil一次性读取整个文件"><a href="#ioutil一次性读取整个文件" class="headerlink" title="ioutil一次性读取整个文件"></a>ioutil一次性读取整个文件</h3><p>需要导入<code>io/ioutil</code>包。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">content, err := ioutil.ReadFile(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;read file failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReadFile</code>函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>ReadFile</code>函数接收文件路径，返回包含整个文件的字节切片和可能的具体错误。</p><h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><p><code>os.OpenFile</code>函数能够以指定模式打开文件，从而实现文件写入相关功能。<br>签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (*File, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><ul><li><code>name</code>：文件路径</li><li><code>flag</code>：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.</span></span><br><span class="line">O_RDONLY <span class="type">int</span> = syscall.O_RDONLY <span class="comment">// open the file read-only.</span></span><br><span class="line">O_WRONLY <span class="type">int</span> = syscall.O_WRONLY <span class="comment">// open the file write-only.</span></span><br><span class="line">O_RDWR   <span class="type">int</span> = syscall.O_RDWR   <span class="comment">// open the file read-write.</span></span><br><span class="line"><span class="comment">// The remaining values may be or&#x27;ed in to control behavior.</span></span><br><span class="line">O_APPEND <span class="type">int</span> = syscall.O_APPEND <span class="comment">// append data to the file when writing.</span></span><br><span class="line">O_CREATE <span class="type">int</span> = syscall.O_CREAT  <span class="comment">// create a new file if none exists.</span></span><br><span class="line">O_EXCL   <span class="type">int</span> = syscall.O_EXCL   <span class="comment">// used with O_CREATE, file must not exist.</span></span><br><span class="line">O_SYNC   <span class="type">int</span> = syscall.O_SYNC   <span class="comment">// open for synchronous I/O.</span></span><br><span class="line">O_TRUNC  <span class="type">int</span> = syscall.O_TRUNC  <span class="comment">// truncate regular writable file when opened.</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>perm</code>：文件权限，一个八进制数。<code>r</code>（读）04，<code>w</code>（写）02，<code>x</code>（执行）01</li></ul><h3 id="Write和WriteString"><a href="#Write和WriteString" class="headerlink" title="Write和WriteString"></a>Write和WriteString</h3><p>直接将内容写入文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := os.OpenFile(<span class="string">&quot;t1.txt&quot;</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;open file failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">str := <span class="string">&quot;hello 浙江\n&quot;</span></span><br><span class="line">file.Write([]<span class="type">byte</span>(str))      <span class="comment">// 写入字节切片数据</span></span><br><span class="line">file.WriteString(<span class="string">&quot;hello 杭州&quot;</span>) <span class="comment">// 直接写入字符串数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Write()</code>方法签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Write(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>Write</code>方法接收一个字节切片，返回值是字节切片长度和可能的具体错误。</p><p><code>WriteString</code>方法签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> WriteString(s <span class="type">string</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> f.Write([]<span class="type">byte</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>WriteString</code>函数就是将传入的字符串转换成字节切片，再调用<code>Write</code>方法，返回值相同。</p><h3 id="bufio-NewWriter"><a href="#bufio-NewWriter" class="headerlink" title="bufio.NewWriter"></a>bufio.NewWriter</h3><p>将数据先写入缓冲区，写完后一次性将缓冲区中的内容写入文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := os.OpenFile(<span class="string">&quot;t1.txt&quot;</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;open file failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">writer := bufio.NewWriter(file)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">writer.WriteString(<span class="string">&quot;hello中国&quot;</span> + strconv.Itoa(i) + <span class="string">&quot;\n&quot;</span>) <span class="comment">// 将数据先写入缓存</span></span><br><span class="line">&#125;</span><br><span class="line">writer.Flush() <span class="comment">// 将缓存中的内容写入文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewWriter</code>函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(w io.Writer)</span></span> *Writer</span><br></pre></td></tr></table></figure><p><code>NewWriter</code>函数会新建一个默认大小的缓冲区，返回该缓冲区指针。</p><p><code>WriteString</code>方法签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> WriteString(s <span class="type">string</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>WriteString</code>方法接收一个字符串，返回已经写入的字节数，如果写入字节数&lt; <code>len(s)</code>，返回具体的错误。</p><p><code>Flush()</code>方法：将缓冲区的内容写入文件。</p><h3 id="ioutil-WriteFile"><a href="#ioutil-WriteFile" class="headerlink" title="ioutil.WriteFile"></a>ioutil.WriteFile</h3><p>将内容直接写入文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">`</span></span><br><span class="line"><span class="string">hello 中国</span></span><br><span class="line"><span class="string">hello 浙江</span></span><br><span class="line"><span class="string">hello 杭州`</span></span><br><span class="line">err := ioutil.WriteFile(<span class="string">&quot;t1.txt&quot;</span>, []<span class="type">byte</span>(str), <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;write file failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WriteFile</code>函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(filename <span class="type">string</span>, data []<span class="type">byte</span>, perm os.FileMode)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure><h2 id="其它文件操作方法-x2F-函数补充"><a href="#其它文件操作方法-x2F-函数补充" class="headerlink" title="其它文件操作方法&#x2F;函数补充"></a>其它文件操作方法&#x2F;函数补充</h2><h3 id="Seek方法设置文件读写位置"><a href="#Seek方法设置文件读写位置" class="headerlink" title="Seek方法设置文件读写位置"></a>Seek方法设置文件读写位置</h3><p>签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Seek(offset <span class="type">int64</span>, whence <span class="type">int</span>) (ret <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>Seek()</code>方法能设置下一次读&#x2F;写的位置。<code>offset</code>为相对偏移量，而<code>whence</code>决定相对位置：0为相对文件开头，1为相对当前位置，2为相对文件结尾。它返回新的偏移量（相对开头）和可能的错误。</p><h3 id="os-Rename函数重命名文件"><a href="#os-Rename函数重命名文件" class="headerlink" title="os.Rename函数重命名文件"></a>os.Rename函数重命名文件</h3><p>注意：使用前需要关闭文件。<br>签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Rename</span><span class="params">(oldpath, newpath <span class="type">string</span>)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.Rename(<span class="string">&quot;./t1.txt&quot;</span>, <span class="string">&quot;./t2.txt&quot;</span>)</span><br></pre></td></tr></table></figure><p>示例中将文件名<code>t1.txt</code>改为<code>t2.txt</code>，重命名的过程中利用<code>newpath</code>还可以移动文件位置。</p><h3 id="os-Remove函数删除文件-x2F-目录"><a href="#os-Remove函数删除文件-x2F-目录" class="headerlink" title="os.Remove函数删除文件&#x2F;目录"></a>os.Remove函数删除文件&#x2F;目录</h3><p>注意：使用前需要关闭文件。<br>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure><p><code>Remove()</code>函数能删除<code>name</code>指定的文件或目录。如果出错，会返回<code>*PathError</code>底层类型的错误。</p><h3 id="path-Join函数路径拼接"><a href="#path-Join函数路径拼接" class="headerlink" title="path.Join函数路径拼接"></a>path.Join函数路径拼接</h3><p>签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(elem ...<span class="type">string</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure><p>Join函数可以将任意数量的路径元素放入一个单一路径里，会根据需要添加斜杠。结果是经过简化的，所有的空字符串元素会被忽略。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(path.Join(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)) <span class="comment">// a/b/c</span></span><br></pre></td></tr></table></figure><h3 id="查看文件信息：名字、大小、模式位等"><a href="#查看文件信息：名字、大小、模式位等" class="headerlink" title="查看文件信息：名字、大小、模式位等"></a>查看文件信息：名字、大小、模式位等</h3><p>查看文件信息可以用<code>os.Stat</code>函数，也可以打开文件后，使用<code>(*File).Stat</code>方法。</p><p>函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stat</span><span class="params">(name <span class="type">string</span>)</span></span> (fi FileInfo, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>Stat</code>返回一个描述<code>name</code>指定的文件对象的<code>FileInfo</code>。如果指定的文件对象是一个符号链接，返回的<code>FileInfo</code>描述该符号链接指向的文件的信息，本函数会尝试跳转该链接。如果出错，返回的错误值为<code>*PathError</code>类型。</p><p>方法签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Stat() (fi FileInfo, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>Stat</code>返回描述文件<code>f</code>的<code>FileInfo</code>类型值。如果出错，错误底层类型是<code>*PathError</code>。</p><p>两者的返回值相同，我们可以通过返回的<code>FileInfo</code>类型值得到文件的相关信息。<br><code>FileInfo</code>类型声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FileInfo用来描述一个文件对象。</span></span><br><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="type">string</span>       <span class="comment">// 文件的名字（不含扩展名）</span></span><br><span class="line">    Size() <span class="type">int64</span>        <span class="comment">// 普通文件返回值表示其大小；其他文件的返回值含义各系统不同</span></span><br><span class="line">    Mode() FileMode     <span class="comment">// 文件的模式位</span></span><br><span class="line">    ModTime() time.Time <span class="comment">// 文件的修改时间</span></span><br><span class="line">    IsDir() <span class="type">bool</span>        <span class="comment">// 等价于Mode().IsDir()</span></span><br><span class="line">    Sys() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// 底层数据来源（可以返回nil）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 使用os.Stat函数获取FileInfo值</span></span><br><span class="line">fileInfo, err := os.Stat(<span class="string">&quot;main.go&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(fileInfo.Name(), fileInfo.Size()) <span class="comment">// main.go 356</span></span><br><span class="line"><span class="comment">// 使用Stat方法获取FileInfo值</span></span><br><span class="line">file, err := os.Open(<span class="string">&quot;main.go&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">fileInfo, err = file.Stat()</span><br><span class="line">fmt.Println(fileInfo.Name(), fileInfo.Size()) <span class="comment">// main.go 356</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://studygolang.com/pkgdoc">更多函数&#x2F;方法可查中文版包文档</a><br><a href="https://www.liwenzhou.com/posts/Go/go_file/">参考</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;文件打开和关闭&quot;&gt;&lt;a href=&quot;#文件打开和关闭&quot; class=&quot;headerlink&quot; title=&quot;文件打开和关闭&quot;&gt;&lt;/a&gt;文件打开和关闭&lt;/h2&gt;&lt;p&gt;&lt;code&gt;os&lt;/code&gt;包中&lt;code&gt;Op</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go" scheme="http://website13.github.io/tags/golang-go/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（17）——包（package）：自定义包、标识符可见性、导入、init()函数、简单实例</title>
    <link href="http://website13.github.io/2020/08/06/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8817%EF%BC%89%E2%80%94%E2%80%94%E5%8C%85%EF%BC%88package%EF%BC%89%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E3%80%81%E6%A0%87%E8%AF%86%E7%AC%A6%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%AF%BC%E5%85%A5%E3%80%81init()%E5%87%BD%E6%95%B0%E3%80%81%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"/>
    <id>http://website13.github.io/2020/08/06/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8817%EF%BC%89%E2%80%94%E2%80%94%E5%8C%85%EF%BC%88package%EF%BC%89%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E3%80%81%E6%A0%87%E8%AF%86%E7%AC%A6%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%AF%BC%E5%85%A5%E3%80%81init()%E5%87%BD%E6%95%B0%E3%80%81%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/</id>
    <published>2020-08-06T06:00:41.000Z</published>
    <updated>2022-07-31T09:22:27.877Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="定义包"><a href="#定义包" class="headerlink" title="定义包"></a>定义包</h2><p>一个包可以简单理解为一个存放<code>.go</code>文件的文件夹。这些<code>go</code>文件都归属于该包，通过在代码第一行声明实现。声明格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>一个包下面的所有文件只能归属于同一个包。</li><li>包名可以和文件夹名不同，包名不能包含<code>-</code>符号。</li><li><code>main</code>包是应用程序的入口包，只有<code>main</code>包才会在编译后生成可执行文件。</li></ul><h2 id="包中标识符的对外可见性"><a href="#包中标识符的对外可见性" class="headerlink" title="包中标识符的对外可见性"></a>包中标识符的对外可见性</h2><p>标识符包括变量、常量、类型、函数等，还有结构体中的字段名、接口中的方法名，Go语言中只要将标识符的首字母大写，就可以让该标识符对外可见。</p><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><p>使用<code>import</code>关键字导入需要使用的包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;包名&quot;</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>导入语句通常放在包声明语句的下面。</li><li>导入的包名需要用双引号包裹。</li><li>对于自定义的包，导入时需要加路径。（如果设置了GOPATH，包名是从<code>$GOPATH/src/</code>后开始计算的，使用<code>/</code>进行路径分隔）</li><li>禁止循环导入包</li></ul><h3 id="单行导入"><a href="#单行导入" class="headerlink" title="单行导入"></a>单行导入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;包1&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;包2&quot;</span></span><br></pre></td></tr></table></figure><h3 id="多行导入"><a href="#多行导入" class="headerlink" title="多行导入"></a>多行导入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;包1&quot;</span></span><br><span class="line"><span class="string">&quot;包2&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="导入时自定义包名"><a href="#导入时自定义包名" class="headerlink" title="导入时自定义包名"></a>导入时自定义包名</h2><p>导入包时可以自定义别名，通常用于包名太长（带路径时名字往往很长）或包名冲突时。<br>用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 别名 <span class="string">&quot;包名&quot;</span></span><br></pre></td></tr></table></figure><p>当不需要使用包中的数据时，可以匿名导入（比如只需要执行包中的<code>init()函数</code>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;包名&quot;</span></span><br></pre></td></tr></table></figure><h2 id="init-初始化函数"><a href="#init-初始化函数" class="headerlink" title="init()初始化函数"></a>init()初始化函数</h2><p>在Go语言程序执行时导入包语句会自动触发包内部<code>init()</code>函数的调用。需要注意的是： <code>init()</code>函数没有参数也没有返回值。 <code>init()</code>函数在程序运行时自动被调用执行，不能在代码中主动调用它。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;自动执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;先执行init()函数&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自动执行</span><br><span class="line">先执行init()函数</span><br></pre></td></tr></table></figure><h3 id="包中init-函数执行时机"><a href="#包中init-函数执行时机" class="headerlink" title="包中init()函数执行时机"></a>包中init()函数执行时机</h3><p>全局声明-&gt;<code>init()</code>函数-&gt;<code>main()</code>函数</p><h3 id="所有init-函数执行顺序"><a href="#所有init-函数执行顺序" class="headerlink" title="所有init()函数执行顺序"></a>所有init()函数执行顺序</h3><p>程序编译时，从<code>main</code>包开始检查导入的包，其中导入的包中可能还导入了其它包。最终可以构建树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。运行时，最后导入的包最先初始化并调用其<code>init()</code>函数。</p><h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h2><p>自定义一个<code>calc</code>包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> calc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// init()函数可以不写，这里是为了体现其执行顺序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;执行calc包的init()函数&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 两数求和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>calc</code>包中<code>Add()</code>函数首字母大写，使其对其它包可见。<br>然后在<code>main</code>包中导入<code>calc</code>包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">calc <span class="string">&quot;xxxx/xxx/xxx/xxx/03calc&quot;</span> <span class="comment">// 使用别名</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// init()函数可以不写，这里是为了体现其执行顺序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;执行main包的init()函数&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(calc.Add(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>calc</code>包文件在文件夹”03calc”下，如果文件夹名和包名相同，可以不取别名，否则需要取别名，别名可以和包名相同。<br>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行calc包的init()函数</span><br><span class="line">执行main包的init()函数</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>calc</code>包后导入，其<code>init()</code>函数先执行。</p><p><a href="https://www.liwenzhou.com/posts/Go/11_package/">参考</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;定义包&quot;&gt;&lt;a href=&quot;#定义包&quot; class=&quot;headerlink&quot; title=&quot;定义包&quot;&gt;&lt;/a&gt;定义包&lt;/h2&gt;&lt;p&gt;一个包可以简单理解为一个存放&lt;code&gt;.go&lt;/code&gt;文件的文件夹。这些&lt;c</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go" scheme="http://website13.github.io/tags/golang-go/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（16）——接口（interface）：基本概念、接口嵌套、空接口、类型断言（获取接口底层值）</title>
    <link href="http://website13.github.io/2020/08/04/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8816%EF%BC%89%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97%E3%80%81%E7%A9%BA%E6%8E%A5%E5%8F%A3%E3%80%81%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%EF%BC%88%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%80%BC%EF%BC%89/"/>
    <id>http://website13.github.io/2020/08/04/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8816%EF%BC%89%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97%E3%80%81%E7%A9%BA%E6%8E%A5%E5%8F%A3%E3%80%81%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%EF%BC%88%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%80%BC%EF%BC%89/</id>
    <published>2020-08-04T13:22:01.000Z</published>
    <updated>2022-07-31T09:22:53.142Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Go语言中<code>接口(interface)</code>是一种类型，一种抽象的类型。<code>接口类型</code>是由一组方法签名定义的集合。<br>接口的定义格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口类型名：自定义，一般会在后面添加<code>er</code>，表明接口类型</li><li>方法名首字母和接口类型名首字母都大写时，该方法可以被其他包访问</li><li>参数列表和返回值列表中可以省略变量名，只保留类型名</li></ul><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>其它类型只要实现了一个接口的所有方法，那么就实现了这个接口。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个包含say()方法的接口</span></span><br><span class="line"><span class="keyword">type</span> sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dog类型实现say()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> say() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;汪~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat类型实现say()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span></span> say() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;喵~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a sayer</span><br><span class="line">a = dog&#123;&#125;</span><br><span class="line">a.say() <span class="comment">// 汪~</span></span><br><span class="line">a = cat&#123;&#125;</span><br><span class="line">a.say() <span class="comment">// 喵~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口类型变量可以存储所有实现该接口的类型变量。上例中，接口类型变量<code>a</code>既可以存储<code>dog</code>类型变量，又可以存储<code>cat</code>类型变量，因为<code>dog</code>和<code>cat</code>类型都实现了该接口的所有方法。<br>有了接口，所有拥有相同方法的自定义类型都可以抽象的用接口类型表示，那么在代码中，如果要对这些自定义类型变量进行相同的操作，就不需要逐个定义和操作，只需要定义一个接口类型变量和操作，就可以适用于所有实现该接口的类型变量。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> say() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;汪~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cat)</span></span> say() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;喵~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">speak</span><span class="params">(s sayer)</span></span> &#123;</span><br><span class="line">s.say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d := &amp;dog&#123;&#125;</span><br><span class="line">c := &amp;cat&#123;&#125;</span><br><span class="line">speak(d) <span class="comment">// 汪~</span></span><br><span class="line">speak(c) <span class="comment">// 喵~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中的<code>speak</code>函数以接口类型变量作为参数，所有实现该接口的类型变量都可以使用该函数，减少了代码的冗余。</p><h3 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h3><ul><li>接口也是值。它们可以像其它值一样传递。</li><li>接口值可以用作函数的参数或返回值。</li><li>在内部，接口值可以看做包含值和具体类型的元组：<code>(value, type)</code>。接口类型变量还未赋值时，<code>value</code>和<code>type</code>都是<code>nil</code>。</li><li>接口值保存了一个具体底层类型的具体值。</li><li>接口值调用方法时会执行其底层类型的同名方法。</li></ul><p>示例接上例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a sayer</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v, %T\n&quot;</span>, a, a) <span class="comment">// &lt;nil&gt;, &lt;nil&gt;</span></span><br><span class="line">a = &amp;dog&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v, %T\n&quot;</span>, a, a) <span class="comment">// &amp;&#123;&#125;, *main.dog</span></span><br></pre></td></tr></table></figure><h2 id="方法中使用值接收者和指针接收者的区别"><a href="#方法中使用值接收者和指针接收者的区别" class="headerlink" title="方法中使用值接收者和指针接收者的区别"></a>方法中使用值接收者和指针接收者的区别</h2><h3 id="值接收者"><a href="#值接收者" class="headerlink" title="值接收者"></a>值接收者</h3><p>接着上例，<code>dog</code>类型的<code>say</code>方法使用的是值接收者，尝试分别用值类型和指针类型的<code>dog</code>类型值给接口类型变量赋值，结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a sayer</span><br><span class="line">a = dog&#123;&#125;</span><br><span class="line">a.say() <span class="comment">// 汪~</span></span><br><span class="line">a = &amp;dog&#123;&#125;</span><br><span class="line">a.say() <span class="comment">// 汪~</span></span><br></pre></td></tr></table></figure><p>可以发现，使用值接收者时，值类型和指针类型的<code>dog</code>类型值都可以赋值给接口变量。这是因为Go语言在编译时会自动给指针求值。</p><h3 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h3><p>还是上例，将<code>cat</code>类型的<code>say</code>方法改成使用指针接收者：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cat)</span></span> say() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;喵~&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试分别用值类型和指针类型的<code>cat</code>类型值给接口类型变量赋值，结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &amp;cat&#123;&#125; <span class="comment">// 正常接收</span></span><br><span class="line">a.say()    <span class="comment">// 喵~</span></span><br><span class="line">a = cat&#123;&#125;  <span class="comment">// 不能接收</span></span><br><span class="line">a.say()</span><br></pre></td></tr></table></figure><p>可以发现，使用指针接收者时，只能使用指针类型的<code>cat</code>类型值给接口类型变量赋值。</p><h2 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a>类型与接口的关系</h2><ul><li>一个类型可以实现多个接口。因为一个类型只要实现一个接口的所有方法，就实现了这个接口。</li><li>多个类型实现同一接口。上面的例子中，<code>dog</code>类型和<code>cat</code>类型都实现了<code>sayer</code>接口的所有方法，所以它们都实现了<code>sayer</code>接口。<br>通过嵌套匿名结构体可以让结构体”继承”匿名结构体的方法（详情见<a href="https://blog.csdn.net/m0_37710023/article/details/107657413">golang基础小记（14）</a>中的嵌套结构体），那么一个接口的方法，不一定需要由一个类型完全实现，而可以通过在类型中嵌入其他类型或者结构体来实现。</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现washingMachine接口需要实现wash()和dry()接口</span></span><br><span class="line"><span class="keyword">type</span> washingMachine <span class="keyword">interface</span> &#123;</span><br><span class="line">wash()</span><br><span class="line">dry()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dryer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dryer类型实现了dry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dryer)</span></span> dry() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;甩一甩&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// haier类型嵌套了匿名结构体，此时haier类型拥有了dryer类型的dry()方法</span></span><br><span class="line"><span class="keyword">type</span> haier <span class="keyword">struct</span> &#123;</span><br><span class="line">dryer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// haier类型实现了wash()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h haier)</span></span> wash() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;洗刷刷&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := haier&#123;dryer&#123;&#125;&#125;</span><br><span class="line"><span class="comment">// 可以看到haier类型的变量能够直接使用dryer类型的dry()方法</span></span><br><span class="line">a.dry() <span class="comment">// 甩一甩</span></span><br><span class="line"><span class="keyword">var</span> b washingMachine</span><br><span class="line"><span class="comment">// 因为haier类型能直接使用dry()方法和wash()方法，所以其实现了washingMachine接口</span></span><br><span class="line">b = a</span><br><span class="line">b.dry() <span class="comment">// 甩一甩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，对于接口来说，一个类型如何实现该接口需要的所有方法并不重要，只要该类型变量可以直接使用这些方法，那么这个类型就实现了该接口。</p><h2 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h2><p>直接给例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> washer <span class="keyword">interface</span> &#123;</span><br><span class="line">wash()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// washingMachine接口嵌套了washer接口</span></span><br><span class="line"><span class="keyword">type</span> washingMachine <span class="keyword">interface</span> &#123;</span><br><span class="line">washer</span><br><span class="line">dry()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dryer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dryer)</span></span> dry() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;甩一甩&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dryer)</span></span> wash() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;洗刷刷&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := dryer&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b washingMachine</span><br><span class="line">b = a <span class="comment">// dryer类型实现了washingMachine接口</span></span><br><span class="line">b.dry()  <span class="comment">// 甩一甩</span></span><br><span class="line">b.wash() <span class="comment">// 洗刷刷</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口可以嵌套接口，那么如果一个类型想实现这个接口，不仅要实现该接口包含的方法，也要实现嵌套接口包含的方法。比如一堆类型既实现了<code>a</code>接口，又实现了<code>b</code>接口，这时就可以利用接口嵌套创造新的接口<code>c</code>，其嵌套了<code>a</code>接口和<code>b</code>接口，那么这堆类型的变量就都可以用接口<code>c</code>类型的变量来存储了。</p><h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>指定了零个方法的接口被称为空接口。<br>格式：<code>interface &#123;&#125;</code><br>空接口可以保存任何类型的值。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyer <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a emptyer</span><br><span class="line">a = <span class="string">&quot;爱中国&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %v\n&quot;</span>, a, a) <span class="comment">// string 爱中国</span></span><br><span class="line">a = <span class="number">15</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %v\n&quot;</span>, a, a) <span class="comment">// int 15</span></span><br><span class="line">a = <span class="literal">true</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %v\n&quot;</span>, a, a) <span class="comment">// bool true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用1——作为函数参数"><a href="#应用1——作为函数参数" class="headerlink" title="应用1——作为函数参数"></a>应用1——作为函数参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// show函数可以接收任意类型的参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %v\n&quot;</span>, e, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">15</span></span><br><span class="line">show(a) <span class="comment">// int 15</span></span><br><span class="line">b := <span class="literal">false</span></span><br><span class="line">show(b) <span class="comment">// bool false</span></span><br><span class="line">c := <span class="string">&quot;爱中国&quot;</span></span><br><span class="line">show(c) <span class="comment">// string 爱中国</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用2——作为map的值"><a href="#应用2——作为map的值" class="headerlink" title="应用2——作为map的值"></a>应用2——作为map的值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m的值可以是任意类型</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="number">3</span>)</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="literal">true</span></span><br><span class="line">m[<span class="number">3</span>] = <span class="string">&quot;爱中国&quot;</span></span><br><span class="line">m[<span class="number">4</span>] = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(m) <span class="comment">// map[1:5 2:true 3:爱中国 4:[1 2 3]]</span></span><br></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p><code>类型断言</code>提供了访问接口底层具体值的方式。<br>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v := i.(T)</span><br></pre></td></tr></table></figure><p>该语句断言接口类型变量 <code>i</code>保存了具体类型 <code>T</code>，并将其底层类型为 <code>T</code>的值赋予变量<code>v</code>。若<code>i</code>并未保存 <code>T</code>类型的值，该语句就会触发一个<code>panic</code>。<br>如果不想触发<code>panic</code>，需要让<code>类型断言</code>返回两个值：底层值以及报告断言是否成功的布尔值。<br>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := i.(T)</span><br></pre></td></tr></table></figure><p>若<code>i</code>保存了一个 <code>T</code>，那么 <code>v</code>将会是其底层值，而 <code>ok</code>为 <code>true</code>。<br>否则，<code>ok</code> 将为<code>false</code>而<code>v</code> 将为 <code>T</code> 类型的零值，程序并不会产生<code>panic</code>。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e是空接口类型变量，让其存储一个string类型的值</span></span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">e = <span class="string">&quot;爱中国&quot;</span></span><br><span class="line">v1, ok1 := e.(<span class="type">string</span>) <span class="comment">// 断言底层类型是string类型</span></span><br><span class="line">fmt.Println(v1, ok1)  <span class="comment">// 爱中国 true</span></span><br><span class="line">v2, ok2 := e.(<span class="type">int</span>)    <span class="comment">// 断言底层类型是int类型</span></span><br><span class="line">fmt.Println(v2, ok2)  <span class="comment">// 0 false</span></span><br></pre></td></tr></table></figure><p>可以用<code>switch</code>实现多次断言：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">e = <span class="string">&quot;爱中国&quot;</span></span><br><span class="line"><span class="comment">// .(type)只能用在switch中</span></span><br><span class="line"><span class="keyword">switch</span> v := e.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;x is a string，value is %v\n&quot;</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;x is a int is %v\n&quot;</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;x is a bool is %v\n&quot;</span>, v)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;unsupport type！&quot;</span>)</span><br><span class="line">&#125; <span class="comment">// x is a string，value is 爱中国</span></span><br></pre></td></tr></table></figure><p><a href="https://tour.go-zh.org/methods/11">参考1</a><br><a href="https://www.liwenzhou.com/posts/Go/12_interface/">参考2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go" scheme="http://website13.github.io/tags/golang-go/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（15）——方法（Method）</title>
    <link href="http://website13.github.io/2020/07/30/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8815%EF%BC%89%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%EF%BC%88Method%EF%BC%89/"/>
    <id>http://website13.github.io/2020/07/30/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8815%EF%BC%89%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%EF%BC%88Method%EF%BC%89/</id>
    <published>2020-07-30T09:27:01.000Z</published>
    <updated>2022-07-31T09:22:51.978Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><code>方法（Method）</code>就是一类带特殊的<code>接收者（Receiver）</code>参数的函数。其与函数的区别在于，函数不属于任何类型，方法属于特定的类型。<br>定义格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span></span> 方法名(参数) 返回值 &#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给myInt类型添加方法，判断值是否大于5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i myInt)</span></span> biggerThanFive() <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">5</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a myInt</span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="comment">// myInt类型的方法只有myInt类型的变量才能使用</span></span><br><span class="line">fmt.Println(a.biggerThanFive()) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：非本地类型不能定义方法<br>基本类型（int、string）等不是本地类型，不能直接定义方法，但我们可以自定义类型，如上例中的<code>myInt</code>，这样就可以为<code>myInt</code>类型添加方法，而且<code>myInt</code>具有<code>int</code>类型的特性。</p><h2 id="接收者参数"><a href="#接收者参数" class="headerlink" title="接收者参数"></a>接收者参数</h2><p>接收者参数可以是值类型，也可以是指针类型。区别在于指针类型，可以在方法中修改变量本身，而值类型只能修改变量副本，不会对变量本身产生影响。<br>以结构体为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line">size, price <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收者变量名一般用类型名首字母的小写</span></span><br><span class="line"><span class="comment">// 接收者参数是值类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h house)</span></span> f1(newSize <span class="type">int</span>) &#123;</span><br><span class="line">h.size = newSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收者参数是指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *house)</span></span> f2(newSize <span class="type">int</span>) &#123;</span><br><span class="line">h.size = newSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h1 := house&#123;</span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="number">150</span>,</span><br><span class="line">&#125;</span><br><span class="line">h1.f1(<span class="number">120</span>) <span class="comment">// 这里可以是h1，也可以是(&amp;h1)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, h1) <span class="comment">// main.house&#123;size:100, price:150&#125;</span></span><br><span class="line">h1.f2(<span class="number">150</span>) <span class="comment">// 这里可以是h1，也可以是(&amp;h1)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v&quot;</span>, h1) <span class="comment">// main.house&#123;size:150, price:150&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，调用<code>f1</code>方法后，变量<code>h1</code>没有被修改；调用<code>f2</code>方法后，变量<code>h1</code>被修改。<br>不管接收者参数是什么类型，方法被调用时，接收者既能为值又能为指针。</p><h3 id="什么时候使用指针类型接收者"><a href="#什么时候使用指针类型接收者" class="headerlink" title="什么时候使用指针类型接收者"></a>什么时候使用指针类型接收者</h3><ol><li>需要修改接收者变量</li><li>拷贝接收者变量的开销较大</li><li>保证一致性，一个方法用了，其他的也用指针类型接收者</li></ol><p><a href="https://www.liwenzhou.com/posts/Go/10_struct/">参考1</a><br><a href="https://tour.go-zh.org/methods/4">参考2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h2&gt;&lt;p&gt;&lt;code&gt;方法（Method）&lt;/code&gt;就是一类带特殊的&lt;code&gt;接收者（Rece</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go" scheme="http://website13.github.io/tags/golang-go/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（14）——结构体：定义、初始化、构造函数、匿名字段、嵌套结构体、JSON序列化与反序列化</title>
    <link href="http://website13.github.io/2020/07/29/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8814%EF%BC%89%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A%E5%AE%9A%E4%B9%89%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5%E3%80%81%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81JSON%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://website13.github.io/2020/07/29/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8814%EF%BC%89%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A%E5%AE%9A%E4%B9%89%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5%E3%80%81%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81JSON%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2020-07-29T12:13:11.000Z</published>
    <updated>2022-07-31T09:22:50.800Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><p>Go语言没有类的概念，但是可以通过结构体实现面向对象编程。<br>结构体是一种自定义数据类型，其可以封装任何类型。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line">size, price <span class="type">float64</span></span><br><span class="line">style <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例<code>house</code>是自定义结构体类型，包括<code>size</code>、<code>price</code>、<code>style</code>三个字段，可以用来描述房子的面积、价格和风格。<code>house</code>类型的变量可以很方便的存储房子信息。</p><h2 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a>结构体实例化</h2><p>结构体是值类型，需要声明后才能使用，声明后内部成员的值默认是对应成员类型的零值。</p><h3 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a>基本实例化</h3><p>使用上面定义的<code>house</code>举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> h1 house</span><br><span class="line">h1.size = <span class="number">130</span></span><br><span class="line">h1.style = <span class="string">&quot;中国风&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, h1) <span class="comment">// &#123;130 0 中国风&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v&quot;</span>, h1)  <span class="comment">// main.house&#123;size:130, price:0, style:&quot;中国风&quot;&#125;</span></span><br><span class="line">fmt.Println(h1.size)   <span class="comment">// 130</span></span><br></pre></td></tr></table></figure><p>通过<code>.</code>来访问结构体的字段（成员变量）</p><h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><p>匿名结构体可以用来定义临时结构体。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> family <span class="keyword">struct</span> &#123;</span><br><span class="line">Mom <span class="type">string</span></span><br><span class="line">Dad <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">family.Mom = <span class="string">&quot;Mommy&quot;</span></span><br><span class="line">family.Dad = <span class="string">&quot;Daddy&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, family)  <span class="comment">// &#123;Mommy Daddy&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, family) <span class="comment">// struct &#123; Mom string; Dad string &#125;&#123;Mom:&quot;Mommy&quot;, Dad:&quot;Daddy&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>上例中<code>family</code>是<code>struct &#123; Mom string; Dad string &#125;</code>类型的变量，因为没有用<code>type</code>关键字定义名字，每次使用都得写清楚结构体类型。</p><h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><ol><li><pre><code>使用`new`关键字</code></pre></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1 := <span class="built_in">new</span>(house)</span><br><span class="line">p1.style = <span class="string">&quot;欧式&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1) <span class="comment">// &amp;main.house&#123;size:0, price:0, style:&quot;欧式&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>Go语言中支持对结构体指针直接使用<code>.</code>来访问结构体的成员。在访问的时候编译器会自动把 <code>p1.style</code> 转为 <code>(*p1).style</code>。</p><ol start="2"><li><pre><code>使用取地址符`&amp;`</code></pre></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p2 := &amp;house&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p2)  <span class="comment">// *main.house</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p2) <span class="comment">// &amp;main.house&#123;size:0, price:0, style:&quot;&quot;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h2><h3 id="直接声明"><a href="#直接声明" class="headerlink" title="直接声明"></a>直接声明</h3><p>成员默认初始化为对应类型的零值。比如之前例子中的<code>var h1 house</code>。</p><h3 id="利用键值对初始化"><a href="#利用键值对初始化" class="headerlink" title="利用键值对初始化"></a>利用键值对初始化</h3><p>（1）对结构体进行键值对初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h3 := house&#123;</span><br><span class="line">size:  <span class="number">110</span>,</span><br><span class="line">price: <span class="number">700</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, h3) <span class="comment">// main.house&#123;size:110, price:700, style:&quot;&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>没必要对每一个成员都设置初始值，未设置初始值的默认为对应类型的零值。<br>（2）对结构体指针进行键值对初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p3 := &amp;house&#123;</span><br><span class="line">size:  <span class="number">110</span>,</span><br><span class="line">price: <span class="number">700</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p3) <span class="comment">// &amp;main.house&#123;size:110, price:700, style:&quot;&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>（3）值的列表初始化<br>也就是初始化的时候省略键，只写值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h4 := house&#123;</span><br><span class="line"><span class="number">110</span>,</span><br><span class="line"><span class="number">940</span>,</span><br><span class="line"><span class="string">&quot;中国风&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, h4) <span class="comment">// main.house&#123;size:110, price:940, style:&quot;中国风&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>需要注意：省略键后，所有成员的值都需要初始化，且顺序要和结构体定义顺序相同。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>Go语言没有结构体的构造函数，但可以手动实现。实现构造函数后可以十分方便的构造结构体变量。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line">size, price <span class="type">float64</span></span><br><span class="line">style       <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回结构体指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newHouse</span><span class="params">(size, price <span class="type">float64</span>, style <span class="type">string</span>)</span></span> *house &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;house&#123;</span><br><span class="line">size:  size,</span><br><span class="line">price: price,</span><br><span class="line">style: style,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := newHouse(<span class="number">100</span>, <span class="number">80</span>, <span class="string">&quot;中国风&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1) <span class="comment">// &amp;main.house&#123;size:100, price:80, style:&quot;中国风&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中的<code>newHouse</code>函数就是一个构造函数，可以用来构造<code>house</code>类型的结构体。构造函数可以返回结构体，也可以返回结构体指针。当结构体比较大的时候，返回结构体会有较大的值拷贝性能开销，这时返回结构体指针更合适。</p><h2 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h2><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为<code>匿名字段</code>。<code>匿名字段</code>默认会采用类型名作为字段名，而结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h1 := house&#123;</span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="string">&quot;中国风&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, h1)        <span class="comment">// main.house&#123;int:100, string:&quot;中国风&quot;&#125;</span></span><br><span class="line">fmt.Println(h1.<span class="type">string</span>, h1.<span class="type">int</span>) <span class="comment">// 中国风 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名字段也可以与非匿名字段混用，示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">height <span class="type">int</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">name <span class="type">string</span></span><br><span class="line"><span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := person&#123;</span><br><span class="line">height: <span class="number">178</span>,</span><br><span class="line"><span class="type">int</span>:    <span class="number">100</span>,</span><br><span class="line">name:   <span class="string">&quot;夏静怡&quot;</span>,</span><br><span class="line"><span class="type">string</span>: <span class="string">&quot;篮球&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1)                   <span class="comment">// main.person&#123;height:178, int:100, name:&quot;夏静怡&quot;, string:&quot;篮球&quot;&#125;</span></span><br><span class="line">fmt.Println(p1.height, p1.<span class="type">int</span>, p1.<span class="type">string</span>) <span class="comment">// 178 100 篮球</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h2><p>嵌套结构体就是一个结构体中包含另一个结构体或结构体指针。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">province, city <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line">size <span class="type">int</span></span><br><span class="line">addr address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h1 := house&#123;</span><br><span class="line">size: <span class="number">100</span>,</span><br><span class="line">addr: address&#123;</span><br><span class="line"><span class="string">&quot;浙江&quot;</span>,</span><br><span class="line"><span class="string">&quot;杭州&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, h1)   <span class="comment">// main.house&#123;size:100, addr:main.address&#123;province:&quot;浙江&quot;, city:&quot;杭州&quot;&#125;&#125;</span></span><br><span class="line"><span class="comment">// 嵌套结构体的成员可以通过&#x27;.&#x27;一层一层的访问</span></span><br><span class="line">fmt.Println(h1.addr.city) <span class="comment">// 杭州</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当嵌套结构体采用匿名字段的方式，其成员可以直接访问。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">province, city <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line">size <span class="type">int</span></span><br><span class="line">address <span class="comment">// 匿名嵌套结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h1 := house&#123;</span><br><span class="line">size: <span class="number">100</span>,</span><br><span class="line">address: address&#123;</span><br><span class="line"><span class="string">&quot;浙江&quot;</span>,</span><br><span class="line"><span class="string">&quot;杭州&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, h1)               <span class="comment">// main.house&#123;size:100, address:main.address&#123;province:&quot;浙江&quot;, city:&quot;杭州&quot;&#125;&#125;</span></span><br><span class="line"><span class="comment">// 匿名字段可以省略</span></span><br><span class="line">fmt.Println(h1.address.city, h1.city) <span class="comment">// 杭州 杭州</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当访问结构体成员时会先在结构体中查找该字段，找不到再去嵌套的匿名字段中查找。嵌套可以多层嵌套，中途的匿名字段都可以省略。<br>注意：如果嵌套结构体内部有相同字段，那么匿名字段也不可省略。<br>模拟“继承”：外层结构体能够使用匿名嵌套结构体的方法。（Go语言没有继承的概念，但可以利用结构体模拟实现）</p><h2 id="结构体字段可见性"><a href="#结构体字段可见性" class="headerlink" title="结构体字段可见性"></a>结构体字段可见性</h2><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p><h2 id="JSON序列化和反序列化"><a href="#JSON序列化和反序列化" class="headerlink" title="JSON序列化和反序列化"></a>JSON序列化和反序列化</h2><p><a href="http://json.cn/">JSON在线解析及格式化验证网站</a></p><h3 id="JSON序列化"><a href="#JSON序列化" class="headerlink" title="JSON序列化"></a>JSON序列化</h3><p>结构体–&gt;JSON格式的字符串。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span> <span class="comment">// 引入json包</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line">Size  <span class="type">int</span>  <span class="comment">// 字段名首字母必须大写，否则json包访问不到字段数据</span></span><br><span class="line">Style <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h1 := house&#123;</span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="string">&quot;中国风&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">data, err := json.Marshal(h1) <span class="comment">// 序列化函数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;json marshal failed&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, data) <span class="comment">// &#123;&quot;Size&quot;:100,&quot;Style&quot;:&quot;中国风&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：当结构体需要被其他包访问时，结构体字段（成员）名首字母必须大写</p><h3 id="JSON反序列化"><a href="#JSON反序列化" class="headerlink" title="JSON反序列化"></a>JSON反序列化</h3><p>JSON格式的字符串–&gt;结构体。<br>字符串中可以没有结构体的字段名，此时该字段值是对应类型的零值。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line">Size  <span class="type">int</span></span><br><span class="line">Style <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">`&#123;&quot;Size&quot;:100,&quot;Style&quot;:&quot;中国风&quot;&#125;`</span> <span class="comment">// JSON格式的字符串</span></span><br><span class="line"><span class="keyword">var</span> h2 house</span><br><span class="line"><span class="comment">// 反序列化函数，参数是[]byte类型的JSON格式字符串和结构体指针（因为要对结构体变量进行修改）</span></span><br><span class="line">err = json.Unmarshal([]<span class="type">byte</span>(str), &amp;h2)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;json unmarshal failed!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, h2) <span class="comment">// main.house&#123;Size:100, Style:&quot;中国风&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体标签（Tag）"><a href="#结构体标签（Tag）" class="headerlink" title="结构体标签（Tag）"></a>结构体标签（Tag）</h3><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。<code>Tag</code>在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`key1:&quot;value1&quot; key2:&quot;value2&quot;`</span></span><br></pre></td></tr></table></figure><p>结构体<code>Tag</code>由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。<br>注意：同一个键值对之间不能加空格<br>在JSON序列化时，由于结构体字段名首字母必须大写，可能无法满足字段名首字母小写的需求，这时就需要使用<code>Tag</code>。示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span> <span class="comment">// 引入json包</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line">Size  <span class="type">int</span>    <span class="string">`json:&quot;size&quot;`</span></span><br><span class="line">Style <span class="type">string</span> <span class="string">`json:&quot;style&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h1 := house&#123;</span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="string">&quot;中国风&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">data, err := json.Marshal(h1) <span class="comment">// 序列化函数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;json marshal failed&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, data) <span class="comment">// &#123;&quot;size&quot;:100,&quot;style&quot;:&quot;中国风&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到JSON序列化后的字符串中，字段名首字母是小写的。<br><a href="https://www.liwenzhou.com/posts/Go/10_struct/">参考1</a><br><a href="https://www.cnblogs.com/wdliu/p/9209419.html">参考2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;结构体定义&quot;&gt;&lt;a href=&quot;#结构体定义&quot; class=&quot;headerlink&quot; title=&quot;结构体定义&quot;&gt;&lt;/a&gt;结构体定义&lt;/h2&gt;&lt;p&gt;Go语言没有类的概念，但是可以通过结构体实现面向对象编程。&lt;br&gt;</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go" scheme="http://website13.github.io/tags/golang-go/"/>
    
  </entry>
  
</feed>
