<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Welcome to my Blog</title>
  
  
  <link href="http://website13.github.io/atom.xml" rel="self"/>
  
  <link href="http://website13.github.io/"/>
  <updated>2022-07-31T09:22:36.783Z</updated>
  <id>http://website13.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>golang基础小记（24）——reflect.DeepEqual函数：判断两个值是否一致</title>
    <link href="http://website13.github.io/2020/08/28/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8824%EF%BC%89%E2%80%94%E2%80%94reflect.DeepEqual%E5%87%BD%E6%95%B0%EF%BC%9A%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%80%BC%E6%98%AF%E5%90%A6%E4%B8%80%E8%87%B4/"/>
    <id>http://website13.github.io/2020/08/28/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8824%EF%BC%89%E2%80%94%E2%80%94reflect.DeepEqual%E5%87%BD%E6%95%B0%EF%BC%9A%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%80%BC%E6%98%AF%E5%90%A6%E4%B8%80%E8%87%B4/</id>
    <published>2020-08-28T10:30:46.000Z</published>
    <updated>2022-07-31T09:22:36.783Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>对于<code>array</code>、<code>slice</code>、<code>map</code>、<code>struct</code>等类型，想要比较两个值是否相等，不能使用<code>==</code>，处理起来十分麻烦，在对效率没有太大要求的情况下，<code>reflect</code>包中的<code>DeepEqual</code>函数完美的解决了比较问题。</p><p>函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeepEqual</span><span class="params">(a1, a2 <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure><p>文档中对该函数的说明：<br><code>DeepEqual</code>函数用来判断两个值是否深度一致：除了类型相同；在可以时（主要是基本类型）会使用<code>==</code>；但还会比较<code>array</code>、<code>slice</code>的<strong>成员</strong>，<code>map</code>的<strong>键值对</strong>，<strong>结构体字段</strong>进行深入比对。<code>map</code>的键值对，对键只使用<code>==</code>，但值会继续往深层比对。<code>DeepEqual</code>函数可以正确处理循环的类型。函数类型只有都会<code>nil</code>时才相等；空切片不等于<code>nil</code>切片；还会考虑<code>array</code>、<code>slice</code>的长度、<code>map</code>键值对数。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m1 := <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="number">1</span>: []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, <span class="number">2</span>: <span class="number">3</span>, <span class="number">3</span>: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="number">1</span>: []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, <span class="number">2</span>: <span class="number">3</span>, <span class="number">3</span>: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line"><span class="keyword">if</span> reflect.DeepEqual(m1, m2) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;相等&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的输出是<code>相等</code>。例子中<code>map</code>的值类型是<code>interface&#123;&#125;</code>，如果自己处理去比较，还要使用<code>swich Type</code>来判断底层类型，十分麻烦。</p><p><a href="https://studygolang.com/pkgdoc">参考标准库中文文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;对于&lt;code&gt;array&lt;/code&gt;、&lt;code&gt;slice&lt;/code&gt;、&lt;code&gt;map&lt;/code&gt;、&lt;code&gt;struct&lt;/code&gt;等类型，想要比较两个值是否相等，不能使用&lt;code&gt;==&lt;/code&gt;，</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="go golang" scheme="http://website13.github.io/tags/go-golang/"/>
    
  </entry>
  
  <entry>
    <title>golang包的日常（5）——sync包：并发同步；sync/atomic包：原子级内存操作</title>
    <link href="http://website13.github.io/2020/08/26/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94sync%E5%8C%85%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%90%8C%E6%AD%A5%EF%BC%9Bsync!atomic%E5%8C%85%EF%BC%9A%E5%8E%9F%E5%AD%90%E7%BA%A7%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C/"/>
    <id>http://website13.github.io/2020/08/26/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94sync%E5%8C%85%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%90%8C%E6%AD%A5%EF%BC%9Bsync!atomic%E5%8C%85%EF%BC%9A%E5%8E%9F%E5%AD%90%E7%BA%A7%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C/</id>
    <published>2020-08-26T05:43:06.000Z</published>
    <updated>2022-07-31T09:22:26.860Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="package-sync"><a href="#package-sync" class="headerlink" title="package sync"></a>package sync</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br></pre></td></tr></table></figure><p><code>sync</code>包提供了基本的同步基元，如互斥锁。除了<code>Once</code>和<code>WaitGroup</code>类型，大部分都是适用于低水平程序线程，高水平的同步使用<code>channel</code>通信更好一些。</p><p>注意：本包的类型的值不应被拷贝。</p><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 包含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WaitGroup</code>用于等待一组线程的结束。父线程调用<code>Add</code>方法来设定应等待的线程的数量。每个被等待的线程在结束时应调用<code>Done</code>方法。同时，主线程里可以调用<code>Wait</code>方法阻塞至所有线程结束。<br><code>WaitGroup</code>对象内部有一个计数器，最初从<code>0</code>开始，它有三个方法：<code>Add</code>, <code>Done</code>, <code>Wait</code> 用来控制计数器的值：</p><ul><li><code>func (wg *WaitGroup) Add(delta int)</code>：<code>Add</code>方法向内部计数加上<code>delta</code>，<code>delta</code>可以是负数；如果内部计数器变为<code>0</code>，<code>Wait</code>方法阻塞等待的所有线程都会释放，如果计数器小于<code>0</code>，方法<code>panic</code>；</li><li><code>func (wg *WaitGroup) Done()</code>：<code>Done</code>方法使<code>WaitGroup</code>计数器的值减<code>1</code>，应在线程的最后执行；</li><li><code>func (wg *WaitGroup) Wait()</code>：<code>Wait</code>方法阻塞直到<code>WaitGroup</code>计数器减为<code>0</code>。</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Printf(<span class="string">&quot;我是f\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> f(&amp;wg)</span><br><span class="line">fmt.Println(<span class="string">&quot;我是main&quot;</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中<code>WaitGroup</code>对象可以阻塞<code>main</code>函数，直到所有<code>goroutine</code>都运行完毕。<br><code>WaitGroup</code>对象是结构体类型，传参时需要使用地址，否则进程会死锁；也可以直接声明全局变量。</p><h3 id="sync-Mutex：互斥锁"><a href="#sync-Mutex：互斥锁" class="headerlink" title="sync.Mutex：互斥锁"></a>sync.Mutex：互斥锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 包含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Mutex</code>是一个互斥锁，可以创建为其他结构体的字段；零值为解锁状态。<code>Mutex</code>类型的锁和线程无关，可以由不同的线程加锁和解锁。</p><p><code>Mutex</code>对象有两个方法：</p><ul><li><code>func (m *Mutex) Lock()</code>：<code>Lock</code>方法锁住<code>m</code>，如果<code>m</code>已经加锁，则阻塞直到<code>m</code>解锁；</li><li><code>func (m *Mutex) Unlock()</code>：<code>Unlock</code>方法解锁<code>m</code>，如果<code>m</code>未加锁会导致运行时错误。锁和线程无关，可以由不同的线程加锁和解锁。</li></ul><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个<code>goroutine</code>可以访问共享资源。</p><p>先举一个不加互斥锁的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int64</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">x = x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后会发现输出不是10000，而且无法预测。这是因为两个<code>goroutine</code>可能同时取到<code>x</code>，最后写入时相当于只进行了一次操作，导致结果出错。<br>对共享资源有修改操作时，可以使用互斥锁。在上例中加入互斥锁：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int64</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">lock.Lock()   <span class="comment">// 在访问共享资源前上锁</span></span><br><span class="line">x = x + <span class="number">1</span>     <span class="comment">// 上锁后其它goroutine无法访问x</span></span><br><span class="line">lock.Unlock() <span class="comment">// 访问完就解锁</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用互斥锁后输出正确结果10000。<br><code>Mutex</code>对象是结构体类型，如果不使用全局变量，那么传参时需要使用地址。</p><h3 id="sync-RWMutex：读写互斥锁"><a href="#sync-RWMutex：读写互斥锁" class="headerlink" title="sync.RWMutex：读写互斥锁"></a>sync.RWMutex：读写互斥锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 包含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RWMutex</code>是读写互斥锁。该锁可以被同时多个读取者持有或唯一个写入者持有。<code>RWMutex</code>可以创建为其他结构体的字段；零值为解锁状态。<code>RWMutex</code>类型的锁也和线程无关，可以由不同的线程加读取锁&#x2F;写入锁和解读取锁&#x2F;写入锁。<br>当一个<code>goroutine</code>获取读取锁之后，其他的<code>goroutine</code>如果是获取读取锁会继续获得锁，如果是获取写入锁就会等待；当一个<code>goroutine</code>获取写入锁之后，其他的<code>goroutine</code>无论是获取读取锁还是写入锁都会等待。</p><p><code>RWMutex</code>对象有 5 个方法：</p><ul><li><code>func (rw *RWMutex) Lock()</code>：<code>Lock</code>方法将<code>rw</code>锁定为写入状态，禁止其他线程读取或者写入；</li><li><code>func (rw *RWMutex) Unlock()</code>：<code>Unlock</code>方法解除<code>rw</code>的写入锁状态，如果<code>rw</code>未加写入锁会导致运行时错误；</li><li><code>func (rw *RWMutex) RLock()</code>：<code>RLock</code>方法将<code>rw</code>锁定为读取状态，禁止其他线程写入，但不禁止读取；</li><li><code>func (rw *RWMutex) RUnlock()</code>：<code>Runlock</code>方法解除<code>rw</code>的读取锁状态，如果<code>rw</code>未加读取锁会导致运行时错误；</li><li><code>func (rw *RWMutex) RLocker() Locker</code>：<code>Rlocker</code>方法返回一个互斥锁，通过调用<code>rw.Rlock</code>和<code>rw.Runlock</code>实现了<code>Locker</code>接口（该接口包含<code>Lock</code>和<code>Unlock</code>两个方法）。</li></ul><p>读写互斥锁的使用方式和互斥锁相同。对于<strong>读多写少</strong>的场景，如果使用互斥锁，那么共享资源始终只能被一个<code>goroutine</code>访问，而读写互斥锁可以让多个只读取共享资源的<code>goroutine</code>同时访问共享资源，这在读多写少场景中能大大节省时间。</p><h3 id="sync-Once：保证函数只执行一次"><a href="#sync-Once：保证函数只执行一次" class="headerlink" title="sync.Once：保证函数只执行一次"></a>sync.Once：保证函数只执行一次</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    done <span class="type">uint32</span> <span class="comment">// 表示函数是否已执行</span></span><br><span class="line">m    Mutex  <span class="comment">// 执行函数时需要上锁，保证只执行一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Once</code>是只执行一次动作的对象。只有一个方法<code>Do</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>)</span><br></pre></td></tr></table></figure><p><code>Do</code>方法当且仅当第一次被调用时才执行函数<code>f</code>。当<code>Once</code>对象已经调用<code>Do</code>方法后，即使更换<code>f</code>函数也不会再执行，所以不同的<code>f</code>函数需要声明不同的<code>Once</code>对象。<br>因为<code>f</code>是没有参数的，如果要执行的<code>f</code>需要传递参数就需要搭配<strong>闭包</strong>来使用，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; config.init(filename) &#125;)</span><br></pre></td></tr></table></figure><p>因为只有<code>f</code>返回后<code>Do</code>方法才会返回，所以<code>f</code>若引起了<code>Do</code>的调用，会导致死锁。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line">onceBody := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Only once&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        once.Do(onceBody)</span><br><span class="line">        done &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    &lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Only once</span><br></pre></td></tr></table></figure><p><code>sync.Once</code>内部包含的互斥锁能保证<code>f</code>的操作是<strong>并发安全</strong>的。</p><h3 id="sync-Map：并发安全的映射"><a href="#sync-Map：并发安全的映射" class="headerlink" title="sync.Map：并发安全的映射"></a>sync.Map：并发安全的映射</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 包含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Map</code>类似于Go <code>map[interface&#123;&#125;]interface&#123;&#125;</code>，但是可以安全地被多个<code>goroutine</code>并发使用，而无需额外的锁定或协调。 加载，存储和删除以分摊的常数时间运行。</p><p><code>Map</code>类型是专用的。 大部分代码应改用带有单独锁定或协调功能的普通map，以提高类型安全性，并使其更易于维护其他不变量以及映射内容。</p><p><code>Map</code>类型针对两种常见用例进行了优化：（1）一个键值对仅写入一次但读取多次，例如在仅增长的cache中；（2）多个goroutine进行读取，写入和覆盖不相交的键值对。在这两种情况下，与搭配单独的Mutex或RWMutex的Go map相比，使用Map可以显著减少锁竞争(Lock Contention)。</p><p><code>Map</code>对象无需初始化，声明后即可直接使用。</p><p><code>Map</code>对象目前有6个方法：</p><ul><li><code>func (m *Map) Delete(key interface&#123;&#125;)</code>：<code>Delete</code>方法删除<code>key</code>对应的值；</li><li><code>func (m *Map) Load(key interface&#123;&#125;) (value interface&#123;&#125;, ok bool)</code>：<code>Load</code>方法返回<code>key</code>对应的值，如果找不到则返回<code>nil</code>，<code>ok</code>表示是否找到值；</li><li><code>func (m *Map) LoadAndDelete(key interface&#123;&#125;) (value interface&#123;&#125;, loaded bool)</code>：<code>LoadAndDelete</code>方法1.15版本才有，其删除<code>key</code>对应的值并返回该值，<code>loaded</code>表示<code>key</code>是否存在；</li><li><code>func (m *Map) LoadOrStore(key, value interface&#123;&#125;) (actual interface&#123;&#125;, loaded bool)</code>：<code>LoadOrStore</code>方法，如果<code>key</code>存在则返回对应的值，如果不存在，则存储传入的<code>key</code>和<code>value</code>，返回传入的<code>value</code>，<code>loaded</code>为<code>true</code>表示载入(load)，为<code>false</code>表示存储(store)；</li><li><code>func (m *Map) Range(f func(key, value interface&#123;&#125;) bool)</code>：<code>Range</code>方法遍历<code>Map</code>对象，函数<code>f</code>接收参数<code>key</code>和<code>value</code>，返回一个<code>bool</code>值，返回<code>true</code>表示直接进行下一循环（接收下一对<code>key-value</code>），返回<code>false</code>表示结束循环（停止遍历）。遍历过程是<strong>无序</strong>的，与存储的顺序无关；</li><li><code>func (m *Map) Store(key, value interface&#123;&#125;)</code>：<code>Store</code>方法存储键值对。</li></ul><p><code>Range</code>方法示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 sync.Map</span><br><span class="line">m1.Store(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">m1.Store(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">m1.Store(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line"><span class="keyword">if</span> k == <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">m1.Range(f)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>因为遍历是无序的，所以输出只是其中一次输出，可以看到遍历到3就结束了。</p><h2 id="package-atomic"><a href="#package-atomic" class="headerlink" title="package atomic"></a>package atomic</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync/atomic&quot;</span></span><br></pre></td></tr></table></figure><p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法，它在用户态就可以完成，因此性能比加锁操作更好。</p><p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。</p><p>这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数&#x2F;类型实现同步更好。</p><p>应通过通信来共享内存，而不通过共享内存实现通信。</p><p><code>atomic</code>包提供的函数如下：</p><h3 id="读取系列"><a href="#读取系列" class="headerlink" title="读取系列"></a>读取系列</h3><p>原子性的获取<code>*addr</code>的值。</p><ul><li><code>func LoadInt32(addr *int32) (val int32)</code></li><li><code>func LoadInt64(addr *int64) (val int64)</code></li><li><code>func LoadUint32(addr *uint32) (val uint32)</code></li><li><code>func LoadUint64(addr *uint64) (val uint64)</code></li><li><code>func LoadUintptr(addr *uintptr) (val uintptr)</code></li><li><code>func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</code></li></ul><h3 id="写入系列"><a href="#写入系列" class="headerlink" title="写入系列"></a>写入系列</h3><p>原子性的将<code>val</code>的值保存到<code>*addr</code>。</p><ul><li><code>func StoreInt32(addr *int32, val int32)</code></li><li><code>func StoreInt64(addr *int64, val int64)</code></li><li><code>func StoreUint32(addr *uint32, val uint32)</code></li><li><code>func StoreUint64(addr *uint64, val uint64)</code></li><li><code>func StoreUintptr(addr *uintptr, val uintptr)</code></li><li><code>func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</code></li></ul><h3 id="修改系列（加减操作）"><a href="#修改系列（加减操作）" class="headerlink" title="修改系列（加减操作）"></a>修改系列（加减操作）</h3><p>原子性的将<code>delta</code>的值添加到<code>*addr</code>并返回新值。</p><ul><li><code>func AddInt32(addr *int32, delta int32) (new int32)</code></li><li><code>func AddInt64(addr *int64, delta int64) (new int64)</code></li><li><code>func AddUint32(addr *uint32, delta uint32) (new uint32)</code></li><li><code>func AddUint64(addr *uint64, delta uint64) (new uint64)</code></li><li><code>func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</code></li></ul><p>特别的，对于<code>AddUint32</code>和<code>AddUint64</code>，以<code>AddUint64</code>为例，如果要让<code>x</code>减去一个值<code>c</code>，调用<code>AddUint64(&amp;x, ^uint64(c-1))</code>；让<code>x</code>减1，调用<code>AddUint64(&amp;x, ^uint64(0))</code>。</p><h3 id="交换系列"><a href="#交换系列" class="headerlink" title="交换系列"></a>交换系列</h3><p>原子性的将<code>new</code>值保存到<code>*addr</code>并返回<code>*addr</code>原来的值。</p><ul><li><code>func SwapInt32(addr *int32, new int32) (old int32)</code></li><li><code>func SwapInt64(addr *int64, new int64) (old int64)</code></li><li><code>func SwapUint32(addr *uint32, new uint32) (old uint32)</code></li><li><code>func SwapUint64(addr *uint64, new uint64) (old uint64)</code></li><li><code>func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)</code></li><li><code>func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</code></li></ul><h3 id="比较并交换系列"><a href="#比较并交换系列" class="headerlink" title="比较并交换系列"></a>比较并交换系列</h3><p>原子性的比较<code>*addr</code>和<code>old</code>，如果相同则将<code>new</code>赋值给<code>*addr</code>并返回真。</p><ul><li><code>func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</code></li><li><code>func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)</code></li><li><code>func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)</code></li><li><code>func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)</code></li><li><code>func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)</code></li><li><code>func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</code></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://studygolang.com/pkgdoc">标准库中文文档</a><br><a href="https://godoc.org/sync">标准库英文文档&#x2F;sync包</a><br><a href="https://www.liwenzhou.com/posts/Go/14_concurrence/#autoid-1-7-4">博客1</a><br><a href="https://blog.csdn.net/jeffrey11223/article/details/79587015">博客2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;package-sync&quot;&gt;&lt;a href=&quot;#package-sync&quot; class=&quot;headerlink&quot; title=&quot;package sync&quot;&gt;&lt;/a&gt;package sync&lt;/h2&gt;&lt;figure </summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="go golang" scheme="http://website13.github.io/tags/go-golang/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（23）——并发之channel、select多路复用</title>
    <link href="http://website13.github.io/2020/08/19/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8823%EF%BC%89%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E4%B9%8Bchannel%E3%80%81select%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://website13.github.io/2020/08/19/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8823%EF%BC%89%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E4%B9%8Bchannel%E3%80%81select%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2020-08-19T09:08:09.000Z</published>
    <updated>2022-07-31T09:22:35.671Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="channel-通道"><a href="#channel-通道" class="headerlink" title="channel(通道)"></a>channel(通道)</h2><p><code>goroutine</code>和<code>channel</code>是 Go 语言秉承的 <code>CSP（Communicating Sequential Process）</code>并发模式的重要实现基础。该并发模式提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存实现通信</strong>。<br><code>channel</code>可以实现在多个<code>goroutine</code>之间进行通信，它是一种特殊的类型，遵循先入先出规则。每一个<code>channel</code>只能传递指定元素类型的数据。</p><h3 id="声明channel"><a href="#声明channel" class="headerlink" title="声明channel"></a>声明channel</h3><p><code>channel</code>是引用类型，声明<code>channel</code>的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 <span class="keyword">chan</span> 元素类型</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">bool</span> <span class="comment">// 声明一个传递布尔值的通道</span></span><br></pre></td></tr></table></figure><p>声明得到的通道的值是<code>nil</code>。</p><h3 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h3><p>通道使用<code>make</code>函数初始化，其格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> 元素类型, [缓冲大小])</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// 未设置缓冲大小，默认是0，所以ch1是无缓冲通道</span></span><br></pre></td></tr></table></figure><h3 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h3><p>使用之前创建的<code>ch1</code>。</p><ul><li>发送：<code>ch1 &lt;- 10</code>，把10发送到ch1中；</li><li>接收：<code>&lt;-ch1</code>，值可以用变量接收；</li><li>关闭：<code>close(ch)</code>，只有在所有数据都发送完毕的时候才需要关闭通道，但关闭通道不是必须的，其可以被垃圾回收机制回收。</li></ul><h3 id="已关闭通道的特点"><a href="#已关闭通道的特点" class="headerlink" title="已关闭通道的特点"></a>已关闭通道的特点</h3><ul><li>发送值会引发<code>panic</code>；</li><li>可以接收值直到通道为空，通道为空时继续接收会得到对应类型的零值；</li><li>再次关闭该通道会引发<code>panic</code>。</li></ul><h3 id="无缓冲通道"><a href="#无缓冲通道" class="headerlink" title="无缓冲通道"></a>无缓冲通道</h3><p>无缓冲的通道就是缓冲大小为0，因为没有缓冲，所以无缓冲通道在发送值的同时必须有一方在接收值，也就是说，接收值和发送值的操作需要在两个 <code>goroutine</code>中，否则程序就会因无限等待而死锁。</p><p>死锁示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fatal <span class="type">error</span>: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">chan</span> send]:</span><br><span class="line">main.main()</span><br><span class="line">e:/<span class="keyword">go</span>/src/github.com/BattleL/studygo/day07/<span class="number">04</span>channel/main.<span class="keyword">go</span>:<span class="number">20</span> +<span class="number">0x5b</span></span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure><p>启用一个<code>goroutine</code>解决死锁问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;-ch</span><br><span class="line">&#125;()</span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">&quot;发送成功&quot;</span>) <span class="comment">// 发送成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序正常运行。</p><h3 id="有缓冲通道"><a href="#有缓冲通道" class="headerlink" title="有缓冲通道"></a>有缓冲通道</h3><p>有缓冲通道，就是缓冲大小&gt;0，如果设置为3，那么该通道就最多能存放3个元素，存满就会阻塞，直到有元素被接收。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">&quot;发送成功&quot;</span>) <span class="comment">// 发送成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内置的<code>len</code>函数可以得到通道的元素数量，<code>cap</code>函数可以得到通道的容量。</p><h3 id="遍历通道"><a href="#遍历通道" class="headerlink" title="遍历通道"></a>遍历通道</h3><p>我们通常使用<code>for range</code>遍历通道，但要注意通道必须在发送完毕后关闭，否则会陷入死锁。<br>遍历方式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123;</span><br><span class="line"><span class="comment">// i就是接收的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断通道关闭"><a href="#判断通道关闭" class="headerlink" title="判断通道关闭"></a>判断通道关闭</h3><p>通道接收时可以有两个返回值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i, ok := &lt;-ch</span><br></pre></td></tr></table></figure><p>其中<code>i</code>是接收值，<code>ok</code>在接收成功时是<code>true</code>，在通道关闭且通道为空时是<code>false</code>。<br>可以利用<code>ok</code>，结合<code>for</code>循环实现通道遍历。</p><h3 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h3><p>当通道作为参数传递时，我们可能希望限制通道只能发送或只能接收，这就需要单向通道。<br>令<code>out</code>参数只能发送，<code>in</code>参数只能接收，函数名为<code>test</code>，无返回值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>, in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>chan&lt;- int</code>是int类型只写单向通道，只能发送不能接收；</li><li><code>&lt;-chan int</code>是int类型只读单向通道，只能接收不能发送。</li></ul><p>注意：双向通道可以转换为单向通道，但反过来不行。</p><h2 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h2><p><code>select</code>可以用于同时从多个通道随机接收数据，其类似于<code>switch</code>语句，有一系列<code>case</code>分支和一个默认的分支。每个<code>case</code>可以对应一个通道的接收&#x2F;发送操作。如果没有默认分支，<code>select</code>会一直等待，直到能够完成某个<code>case</code>的操作，如果多个分支都能完成，则随机选择一个。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">fmt.Println(x)</span><br><span class="line"><span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p>如果将例子中的通道容量设为2，那么就会出现两个分支同时满足的情况，因为分支选择的随机性，输出将无法预测。<br><code>select</code>的用途：</p><ul><li>提高代码可读性；</li><li>处理一个或多个通道的发送&#x2F;接收操作；</li><li>多个分支同时满足时会随机选择（如果自己遍历判断，则规定了执行顺序）；</li><li>没有分支的<code>select &#123;&#125;</code>会一直等待，可以用于阻塞<code>main</code>函数。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.liwenzhou.com/posts/Go/14_concurrence/#autoid-1-3-3">参考</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;channel-通道&quot;&gt;&lt;a href=&quot;#channel-通道&quot; class=&quot;headerlink&quot; title=&quot;channel(通道)&quot;&gt;&lt;/a&gt;channel(通道)&lt;/h2&gt;&lt;p&gt;&lt;code&gt;gorou</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go" scheme="http://website13.github.io/tags/golang-go/"/>
    
  </entry>
  
  <entry>
    <title>golang包的日常（4）——math/rand包：生成随机数</title>
    <link href="http://website13.github.io/2020/08/17/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94math!rand%E5%8C%85%EF%BC%9A%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <id>http://website13.github.io/2020/08/17/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94math!rand%E5%8C%85%EF%BC%9A%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</id>
    <published>2020-08-17T10:21:19.000Z</published>
    <updated>2022-07-31T09:22:25.310Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="package-rand"><a href="#package-rand" class="headerlink" title="package rand"></a>package rand</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/rand&quot;</span></span><br></pre></td></tr></table></figure><p><code>rand</code>包实现了伪随机数生成器。</p><h2 id="常用随机数生成方法"><a href="#常用随机数生成方法" class="headerlink" title="常用随机数生成方法"></a>常用随机数生成方法</h2><p>这里只介绍自己用到过的部分，更多函数&#x2F;方法请参考<a href="https://studygolang.com/pkgdoc">标准库文档中文版</a></p><h3 id="rand-Seed：设置随机数种子"><a href="#rand-Seed：设置随机数种子" class="headerlink" title="rand.Seed：设置随机数种子"></a>rand.Seed：设置随机数种子</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Seed</span><span class="params">(seed <span class="type">int64</span>)</span></span></span><br></pre></td></tr></table></figure><p>使用给定的<code>seed</code>将默认资源初始化到一个确定的状态；如未调用<code>Seed</code>，默认资源的行为就好像调用了<code>Seed(1)</code>。<br>如果程序每次运行，随机数种子都相同，那么使用随机数函数得到的随机数都是一样的，想让程序每次运行得到的随机数都不同，就需要让每次的随机数种子不相同。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano()) <span class="comment">// 取纳秒时间戳，可以保证每次的随机数种子都不同</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">fmt.Println(rand.Intn(<span class="number">1000</span>)) <span class="comment">// Intn(n)返回一个取值范围在[0,n)的伪随机int值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">357</span></span><br><span class="line"><span class="number">762</span></span><br><span class="line"><span class="number">182</span></span><br><span class="line"><span class="number">207</span></span><br><span class="line"><span class="number">646</span></span><br></pre></td></tr></table></figure><p>第二次输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">435</span></span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">673</span></span><br><span class="line"><span class="number">573</span></span><br><span class="line"><span class="number">491</span></span><br></pre></td></tr></table></figure><h3 id="rand-Int：生成非负伪随机int值"><a href="#rand-Int：生成非负伪随机int值" class="headerlink" title="rand.Int：生成非负伪随机int值"></a>rand.Int：生成非负伪随机int值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Int</span><span class="params">()</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure><p>返回一个非负的伪随机int值。</p><p>还有生成各种整型随机数的函数：</p><ul><li><code>func Int31() int32</code>：返回一个int32类型的非负的31位伪随机数；</li><li><code>func Int63() int64</code>：返回一个int64类型的非负的63位伪随机数；</li><li><code>func Uint32() uint32</code>：返回一个uint32类型的非负的32位伪随机数。</li></ul><h3 id="rand-Intn-n-：生成取值范围-0-n-的伪随机int值"><a href="#rand-Intn-n-：生成取值范围-0-n-的伪随机int值" class="headerlink" title="rand.Intn(n)：生成取值范围[0, n)的伪随机int值"></a>rand.Intn(n)：生成取值范围[0, n)的伪随机int值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Intn</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure><p>返回一个取值范围在[0,n)的伪随机int值，如果n&lt;&#x3D;0会panic。</p><p>还有生成各种整型范围随机数的函数：</p><ul><li><code>func Int31n(n int32) int32</code>：返回一个取值范围在[0,n)的伪随机int32值，如果n&lt;&#x3D;0会panic；</li><li><code>func Int63n(n int64) int64</code>：返回一个取值范围在[0, n)的伪随机int64值，如果n&lt;&#x3D;0会panic。</li></ul><h3 id="rand-Float32：生成取值范围-0-0-1-0-的伪随机float32值"><a href="#rand-Float32：生成取值范围-0-0-1-0-的伪随机float32值" class="headerlink" title="rand.Float32：生成取值范围[0.0, 1.0)的伪随机float32值"></a>rand.Float32：生成取值范围[0.0, 1.0)的伪随机float32值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float32</span><span class="params">()</span></span> <span class="type">float32</span></span><br></pre></td></tr></table></figure><p>返回一个取值范围在[0.0, 1.0)的伪随机float32值。</p><p>还有生成float64值的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64</span><span class="params">()</span></span> <span class="type">float64</span></span><br></pre></td></tr></table></figure><p>返回一个取值范围在[0.0, 1.0)的伪随机float64值。</p><h3 id="NormFloat64：标准正态分布"><a href="#NormFloat64：标准正态分布" class="headerlink" title="NormFloat64：标准正态分布"></a>NormFloat64：标准正态分布</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NormFloat64</span><span class="params">()</span></span> <span class="type">float64</span></span><br></pre></td></tr></table></figure><p>返回一个服从标准正态分布（标准差&#x3D;1，期望&#x3D;0）、取值范围在<code>[-math.MaxFloat64, +math.MaxFloat64]</code>的<code>float64</code>值。</p><p>如果要生成不同的正态分布值，调用者可用如下代码调整输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sample = NormFloat64() * 标准差 + 期望</span><br></pre></td></tr></table></figure><h3 id="ExpFloat64：标准指数分布"><a href="#ExpFloat64：标准指数分布" class="headerlink" title="ExpFloat64：标准指数分布"></a>ExpFloat64：标准指数分布</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExpFloat64</span><span class="params">()</span></span> <span class="type">float64</span></span><br></pre></td></tr></table></figure><p>返回一个服从标准指数分布（率参数&#x3D;1，率参数是期望的倒数）、取值范围在<code>(0, +math.MaxFloat64]</code>的<code>float64</code>值。</p><p>如要生成不同的指数分布值，调用者可用如下代码调整输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sample = ExpFloat64() / 率参数</span><br></pre></td></tr></table></figure><h3 id="Perm：生成随机排列的整数切片"><a href="#Perm：生成随机排列的整数切片" class="headerlink" title="Perm：生成随机排列的整数切片"></a>Perm：生成随机排列的整数切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Perm</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">int</span></span><br></pre></td></tr></table></figure><p>返回一个有n个元素的，[0,n)范围内整数的伪随机排列的切片。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(rand.Perm(<span class="number">10</span>)) <span class="comment">// [3 7 0 1 9 2 4 5 6 8]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;package-rand&quot;&gt;&lt;a href=&quot;#package-rand&quot; class=&quot;headerlink&quot; title=&quot;package rand&quot;&gt;&lt;/a&gt;package rand&lt;/h2&gt;&lt;figure </summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="go golang random" scheme="http://website13.github.io/tags/go-golang-random/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（22）——并发之goroutine：使用方式、sync.WaitGroup</title>
    <link href="http://website13.github.io/2020/08/17/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8822%EF%BC%89%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E4%B9%8Bgoroutine%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E3%80%81sync.WaitGroup/"/>
    <id>http://website13.github.io/2020/08/17/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8822%EF%BC%89%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E4%B9%8Bgoroutine%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E3%80%81sync.WaitGroup/</id>
    <published>2020-08-17T09:30:54.000Z</published>
    <updated>2022-07-31T09:22:34.614Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><p>Go语言的并发通过<code>goroutine</code>实现，其概念类似于线程，属于用户态的线程，我们可以创建很多个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go的运行时(<code>runtime</code>)来调度和管理的。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>启动<code>goroutine</code>只需要在调用的函数前加上<code>go</code>关键字，函数可以是普通函数也可以是匿名函数。<br>在程序启动时，Go程序会为<code>main()</code>函数创建一个默认的<code>goroutine</code>。它会在<code>main()</code>函数返回的时候结束，此时所有在<code>main()</code>函数中启动的<code>goroutine</code>不管有没有运行完都会一同结束。<br>如下例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;我是f1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> f1()</span><br><span class="line">fmt.Println(<span class="string">&quot;我是main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我是main</span><br></pre></td></tr></table></figure><p>可以发现，函数<code>f1</code>并没有打印结果，这是因为<code>goroutine</code>启动需要一定的时间，而例子中的<code>main()</code>函数早就结束了，在其中启动的<code>goroutine</code>也随之结束。<br>再看下例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;我是f1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> f1()</span><br><span class="line">fmt.Println(<span class="string">&quot;我是main&quot;</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是main</span><br><span class="line">我是f1</span><br></pre></td></tr></table></figure><p>我们让<code>main()</code>函数简单的睡眠1秒钟，让<code>goroutine</code>有时间执行完。因为<code>goroutine</code>启动需要时间，所以这里<code>&quot;我是main&quot;</code>先输出。</p><h2 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h2><p>当我们启动多个<code>goroutine</code>时，我们难以确定要让<code>main()</code>函数睡眠多久，这时我们可以使用<code>sync.WaitGroup</code>来实现<code>goroutine</code>的同步。</p><h3 id="sync-WaitGroup介绍"><a href="#sync-WaitGroup介绍" class="headerlink" title="sync.WaitGroup介绍"></a>sync.WaitGroup介绍</h3><p><code>WaitGroup</code> 对象内部有一个计数器，最初从<code>0</code>开始，它有三个方法：<code>Add()</code>, <code>Done()</code>, <code>Wait()</code> 用来控制计数器的数量。<code>Add(n)</code> 每次让计数器<code>+n</code>，<code>n</code>不能让计数器为负，否则会引发<code>panic</code>；<code>Done()</code> 每次让计数器<code>-1</code> ，<code>wait()</code> 会阻塞代码的运行，直到计数器的值为<code>0</code>。<br><code>WaitGroup</code> 对象是结构体类型，传参时需要使用地址，否则进程会死锁。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Printf(<span class="string">&quot;我是f%d\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> f(i, &amp;wg)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;我是main&quot;</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我是f8</span><br><span class="line">我是f3</span><br><span class="line">我是f9</span><br><span class="line">我是f5</span><br><span class="line">我是f6</span><br><span class="line">我是f7</span><br><span class="line">我是f1</span><br><span class="line">我是f0</span><br><span class="line">我是f2</span><br><span class="line">我是main</span><br><span class="line">我是f4</span><br></pre></td></tr></table></figure><p>每次的输出顺序都可能不同，因为并发执行时<code>goroutine</code>的调度是随机的。</p><h3 id="设置程序占用的最大逻辑核心数"><a href="#设置程序占用的最大逻辑核心数" class="headerlink" title="设置程序占用的最大逻辑核心数"></a>设置程序占用的最大逻辑核心数</h3><p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数，Go1.5版本后默认为当前机器的CPU逻辑核心数。<br>使用方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(<span class="number">4</span>) <span class="comment">// 将程序可占用的最大核心数设置为4个，最多4个任务并行</span></span><br></pre></td></tr></table></figure><p>通过<code>runtime.NumCPU()</code>函数可以获取当前机器的CPU逻辑核心数。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.liwenzhou.com/posts/Go/14_concurrence/#autoid-1-1-0">参考1</a>：一些概念：goroutine与线程的关系<br><a href="https://studygolang.com/articles/12972?fr=sidebar">参考2</a>：关于sync.WaitGroup的用法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;goroutine&quot;&gt;&lt;a href=&quot;#goroutine&quot; class=&quot;headerlink&quot; title=&quot;goroutine&quot;&gt;&lt;/a&gt;goroutine&lt;/h1&gt;&lt;p&gt;Go语言的并发通过&lt;code&gt;go</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go 多线程" scheme="http://website13.github.io/tags/golang-go-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>golang包的日常（3）——strconv包：基本数据类型和其字符串表示的相互转换</title>
    <link href="http://website13.github.io/2020/08/16/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94strconv%E5%8C%85%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%85%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E7%A4%BA%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"/>
    <id>http://website13.github.io/2020/08/16/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94strconv%E5%8C%85%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%85%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E7%A4%BA%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-08-16T09:30:33.000Z</published>
    <updated>2022-07-31T09:22:24.463Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="package-strconv"><a href="#package-strconv" class="headerlink" title="package strconv"></a>package strconv</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br></pre></td></tr></table></figure><p><code>strconv</code>包实现了基本数据类型和其字符串表示的相互转换。</p><p>下面介绍比较常用的转换函数，更多内容参考<a href="https://studygolang.com/pkgdoc">标准库文档中文版</a></p><h2 id="string与int互转"><a href="#string与int互转" class="headerlink" title="string与int互转"></a>string与int互转</h2><h3 id="ParseInt：字符串转int64"><a href="#ParseInt：字符串转int64" class="headerlink" title="ParseInt：字符串转int64"></a>ParseInt：字符串转int64</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="type">string</span>, base <span class="type">int</span>, bitSize <span class="type">int</span>)</span></span> (i <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>返回字符串表示的整数值，接受正负号。<br><code>base</code>指定进制（2到36），如果<code>base</code>为<code>0</code>，则会从字符串前置判断，<code>&quot;0x&quot;</code>是<code>16</code>进制，<code>&quot;0&quot;</code>是<code>8</code>进制，否则是<code>10</code>进制；<br><code>bitSize</code>指定结果必须能无溢出赋值的整数类型，<code>0</code>、<code>8</code>、<code>16</code>、<code>32</code>、<code>64</code> 分别代表 <code>int</code>、<code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code>；返回的<code>err</code>是<code>*NumErr</code>类型的，如果语法有误，<code>err.Error = ErrSyntax</code>；如果结果超出类型范围<code>err.Error = ErrRange</code>。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int32</span></span><br><span class="line">s := <span class="string">&quot;1111&quot;</span></span><br><span class="line">v, err := strconv.ParseInt(s, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">a = <span class="type">int32</span>(v)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, a) <span class="comment">// 1111</span></span><br></pre></td></tr></table></figure><p>例子中选择<code>10</code>进制，<code>bitSize</code>指定<code>64</code>能最大程度的保证赋值无溢出，因为返回值是<code>int64</code>类型，而<code>a</code>是<code>int32</code>类型，所以需要强制转换。</p><h3 id="Atoi：ParseInt-s-10-0-的简写"><a href="#Atoi：ParseInt-s-10-0-的简写" class="headerlink" title="Atoi：ParseInt(s, 10, 0)的简写"></a>Atoi：ParseInt(s, 10, 0)的简写</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atoi</span><span class="params">(s <span class="type">string</span>)</span></span> (i <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><h3 id="ParseUint：字符串转无符号整型"><a href="#ParseUint：字符串转无符号整型" class="headerlink" title="ParseUint：字符串转无符号整型"></a>ParseUint：字符串转无符号整型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseUint</span><span class="params">(s <span class="type">string</span>, base <span class="type">int</span>, bitSize <span class="type">int</span>)</span></span> (n <span class="type">uint64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>ParseUint</code>类似<code>ParseInt</code>但不接受正负号，用于无符号整型。</p><h3 id="FormatInt：int64转指定进制的字符串"><a href="#FormatInt：int64转指定进制的字符串" class="headerlink" title="FormatInt：int64转指定进制的字符串"></a>FormatInt：int64转指定进制的字符串</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="type">int64</span>, base <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure><p>返回<code>i</code>的<code>base</code>进制的字符串表示。<code>base</code>必须在<code>2</code>到<code>36</code>之间，结果中会使用小写字母<code>&#39;a&#39;</code>到<code>&#39;z&#39;</code>表示大于<code>10</code>的数字。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int32</span> = <span class="number">15</span></span><br><span class="line">s := strconv.FormatInt(<span class="type">int64</span>(a), <span class="number">2</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, s) <span class="comment">// “1111”</span></span><br></pre></td></tr></table></figure><p>其它整型类型需要强转到<code>int64</code>类型。例子中选择二进制。</p><h3 id="Itoa：FormatInt-i-10-的简写"><a href="#Itoa：FormatInt-i-10-的简写" class="headerlink" title="Itoa：FormatInt(i, 10) 的简写"></a>Itoa：FormatInt(i, 10) 的简写</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Itoa</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure><h3 id="FormatUint：int64转指定进制的字符串"><a href="#FormatUint：int64转指定进制的字符串" class="headerlink" title="FormatUint：int64转指定进制的字符串"></a>FormatUint：int64转指定进制的字符串</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatUint</span><span class="params">(i <span class="type">uint64</span>, base <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure><p>是FormatInt的无符号整数版本。</p><h2 id="string和float互转"><a href="#string和float互转" class="headerlink" title="string和float互转"></a>string和float互转</h2><h3 id="ParseFloat：字符串转float64"><a href="#ParseFloat：字符串转float64" class="headerlink" title="ParseFloat：字符串转float64"></a>ParseFloat：字符串转float64</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="type">string</span>, bitSize <span class="type">int</span>)</span></span> (f <span class="type">float64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>解析一个表示浮点数的字符串并返回其值。<br>如果<code>s</code>合乎语法规则，函数会返回最为接近<code>s</code>表示值的一个浮点数（使用IEEE754规范舍入）。<code>bitSize</code>指定了期望的接收类型，<code>32</code>是<code>float32</code>（返回值可以不改变精确值的赋值给float32），<code>64</code>是<code>float64</code>；返回值<code>err</code>是<code>*NumErr</code>类型的，语法有误的，<code>err.Error=ErrSyntax</code>；结果超出表示范围的，返回值<code>f</code>为<code>±Inf</code>，<code>err.Error= ErrRange</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">float32</span></span><br><span class="line">s := <span class="string">&quot;1111111.111&quot;</span></span><br><span class="line">v, err := strconv.ParseFloat(s, <span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">a = <span class="type">float32</span>(v)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, a) <span class="comment">// 1.1111111e+06</span></span><br></pre></td></tr></table></figure><p>注意返回值是<code>float64</code>类型，不能用<code>float32</code>类型的变量接收，需要强制转换。</p><h3 id="FormatFloat：浮点数转字符串"><a href="#FormatFloat：浮点数转字符串" class="headerlink" title="FormatFloat：浮点数转字符串"></a>FormatFloat：浮点数转字符串</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="type">float64</span>, fmt <span class="type">byte</span>, prec, bitSize <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure><p>函数将浮点数表示为字符串并返回。<br><code>bitSize</code>表示<code>f</code>的来源类型（32：float32、64：float64），会据此进行舍入。<br><code>fmt</code>表示格式：<code>&#39;f&#39;</code>（-ddd.dddd）、<code>&#39;b&#39;</code>（-ddddp±ddd，指数为二进制）、<code>&#39;e&#39;</code>（-d.dddde±dd，十进制指数）、<code>&#39;E&#39;</code>（-d.ddddE±dd，十进制指数）、<code>&#39;g&#39;</code>（指数很大时用’e’格式，否则’f’格式）、<code>&#39;G&#39;</code>（指数很大时用’E’格式，否则’f’格式）。<br><code>prec</code>控制精度（排除指数部分）：对’f’、‘e’、‘E’，它表示小数点后的数字个数；对’g’、‘G’，它控制总的数字个数。如果<code>prec</code> 为<code>-1</code>，则代表使用最少数量的、但又必需的数字来表示<code>f</code>。</p><h2 id="string和bool互转"><a href="#string和bool互转" class="headerlink" title="string和bool互转"></a>string和bool互转</h2><h3 id="ParseBool：字符串转bool"><a href="#ParseBool：字符串转bool" class="headerlink" title="ParseBool：字符串转bool"></a>ParseBool：字符串转bool</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(str <span class="type">string</span>)</span></span> (value <span class="type">bool</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>返回字符串表示的<code>bool</code>值。它接受<code>1</code>、<code>0</code>、<code>t</code>、<code>f</code>、<code>T</code>、<code>F</code>、<code>true</code>、<code>false</code>、<code>True</code>、<code>False</code>、<code>TRUE</code>、<code>FALSE</code>；否则返回错误。</p><h3 id="FormatBool：bool转字符串"><a href="#FormatBool：bool转字符串" class="headerlink" title="FormatBool：bool转字符串"></a>FormatBool：bool转字符串</h3><p>根据b的值返回”true”或”false”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;package-strconv&quot;&gt;&lt;a href=&quot;#package-strconv&quot; class=&quot;headerlink&quot; title=&quot;package strconv&quot;&gt;&lt;/a&gt;package strconv&lt;</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go" scheme="http://website13.github.io/tags/golang-go/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（21）——反射</title>
    <link href="http://website13.github.io/2020/08/14/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8821%EF%BC%89%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84/"/>
    <id>http://website13.github.io/2020/08/14/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8821%EF%BC%89%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84/</id>
    <published>2020-08-14T04:21:14.000Z</published>
    <updated>2022-07-31T09:22:33.484Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>反射是指在程序运行期间对程序本身进行访问和修改的能力。<br>反射的应用：当我们用空接口接收不同类型的结构体时，很难用类型断言去判断类型（因为自定义类型可以随意取名），这时就可以用到反射，来来得到结构体的类型，并进一步得到字段和对应值。<br>实际应用：<code>json</code>等数据解析（比如结构体博客中JSON序列化与反序列化）&#x2F;ORM等工具<br>注意：</p><ul><li>反射引起的<code>panic</code>在编译时不会产生，只有在运行时才能发现，所以代码比较脆弱</li><li>应用反射的代码通常难以理解</li><li>反射的性能更低<br>所以在写代码时要尽量避免使用反射，除非只能使用反射！（这也是我不想写细致内容的借口。。。以后用到再说。。。）</li></ul><p><code>reflect</code>包提供反射相关功能。</p><p>反射细致内容可以参考下面三个文档：</p><ol><li><a href="https://www.liwenzhou.com/posts/Go/13_reflect/">这篇博客</a>对于反射的各种函数和使用方式讲的比较细致</li><li><a href="https://www.jb51.net/article/154883.htm">这篇文章</a>从应用出发循序渐进，更容易理解反射</li><li><a href="https://studygolang.com/pkgdoc">标准库文档中文版</a>，实际写代码时，对于各种方法&#x2F;函数还是查文档更清晰一些，文档还推荐了一篇英文版的反射介绍</li></ol><h2 id="一些可能常用的方法"><a href="#一些可能常用的方法" class="headerlink" title="一些可能常用的方法"></a>一些可能常用的方法</h2><p>注意：所有值都默认用静态类型interface{}保存；只有用法，没有理由，具体可以查看参考中的标准库中文文档，或者代码实践。<br>该空接口类型变量名为<code>data</code></p><h3 id="判断data底层类型"><a href="#判断data底层类型" class="headerlink" title="判断data底层类型"></a>判断data底层类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断data的底层类型是否是指针类型</span></span><br><span class="line"><span class="keyword">if</span> reflect.TypeOf(data).Kind() != reflect.Ptr &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;data 不是指针类型&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>Kind</code>方法的返回值是<code>Kind</code>类型，<code>reflect</code>包中定义了很多<code>Kind</code>类型常量代表各种底层类型，<code>Ptr</code>就是其中一种。</p><h3 id="获得指针指向的值的底层类型"><a href="#获得指针指向的值的底层类型" class="headerlink" title="获得指针指向的值的底层类型"></a>获得指针指向的值的底层类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflect.TypeOf(data).Elem().Kind()</span><br></pre></td></tr></table></figure><p>其中<code>Elem</code>方法返回该类型的元素类型，如果该类型的<code>Kind</code>不是Array、Chan、Map(Map类型的元素是值)、Ptr或Slice，会<code>panic</code>。</p><h3 id="获得结构体字段数量"><a href="#获得结构体字段数量" class="headerlink" title="获得结构体字段数量"></a>获得结构体字段数量</h3><p>此时<code>data</code>的底层类型是结构体。如果底层类型是指针，可以使用前面的<code>Elem</code>方法得到其值类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := reflect.TypeOf(data)</span><br><span class="line">num := t.NumField() <span class="comment">// 此时num的值就是结构体字段数量</span></span><br></pre></td></tr></table></figure><p>其中<code>NumField</code>方法返回struct类型的字段数（匿名字段算作一个字段），如非结构体类型将<code>panic</code>。</p><h3 id="获得结构体第i个字段的类型"><a href="#获得结构体第i个字段的类型" class="headerlink" title="获得结构体第i个字段的类型"></a>获得结构体第i个字段的类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t := reflect.TypeOf(data)</span><br><span class="line">field := t.Field(<span class="number">0</span>) <span class="comment">// 返回的field是reflect.StructField类型</span></span><br><span class="line">fieldName := field.Name <span class="comment">// 得到字段名</span></span><br><span class="line">fieldType := field.Type <span class="comment">// 得到字段类型，返回值类型是reflect.Type</span></span><br><span class="line">fieldTag := field.Tag <span class="comment">// 得到字段的Tag，返回值类型是reflect.StructTag，该类型有Get(string) string方法，可以获得Tag中键对应的值</span></span><br></pre></td></tr></table></figure><p><code>Field</code>方法返回<code>struct</code>类型的第<code>i</code>个字段的类型，如非结构体或者<code>i</code>不在<code>[0, NumField())</code>内将会<code>panic</code>。<br><code>Field</code>方法一般和<code>NumField</code>方法在循环中使用。</p><h3 id="根据字段名得到结构体的字段类型"><a href="#根据字段名得到结构体的字段类型" class="headerlink" title="根据字段名得到结构体的字段类型"></a>根据字段名得到结构体的字段类型</h3><p>假设<code>structName</code>是字段名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t := reflect.TypeOf(data)</span><br><span class="line">structField, ok := t.FieldByName(structName)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;字段名不存在&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">structObjType := structField.Type <span class="comment">// 得到字段类型</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;反射是指在程序运行期间对程序本身进行访问和修改的能力。&lt;br&gt;反射的应用：当我们用空接口接收不同类型的结构体时，很难用类型断言去判断类型（因为自定义类型可以随意取名），这时就可以用到反射，来来得到结构体的类型，并进一步得到字</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="go golang" scheme="http://website13.github.io/tags/go-golang/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（20）——将格式化字符串作为函数参数</title>
    <link href="http://website13.github.io/2020/08/10/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8820%EF%BC%89%E2%80%94%E2%80%94%E5%B0%86%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"/>
    <id>http://website13.github.io/2020/08/10/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8820%EF%BC%89%E2%80%94%E2%80%94%E5%B0%86%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</id>
    <published>2020-08-10T09:22:01.000Z</published>
    <updated>2022-07-31T09:22:32.103Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>直接上简单实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatAsArgs</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">s := fmt.Sprintf(format, a...)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">name := <span class="string">&quot;小明&quot;</span></span><br><span class="line">id := <span class="number">10086</span></span><br><span class="line">formatAsArgs(<span class="string">&quot;name:%s, id:%d&quot;</span>, name, id) <span class="comment">// name:小明, id:10086</span></span><br><span class="line">formatAsArgs(<span class="string">&quot;name, id&quot;</span>) <span class="comment">// name, id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数<code>a ...interface&#123;&#125;</code>使得函数可以接收0个及以上的参数，使得函数既能接收普通字符串，也能接收格式化字符串。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;直接上简单实例：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go 字符串" scheme="http://website13.github.io/tags/golang-go-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（19）——runtime.Caller简单使用：获取函数名和对应的文件名、行号</title>
    <link href="http://website13.github.io/2020/08/10/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8819%EF%BC%89%E2%80%94%E2%80%94runtime.Caller%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E5%90%8D%E5%92%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D%E3%80%81%E8%A1%8C%E5%8F%B7/"/>
    <id>http://website13.github.io/2020/08/10/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8819%EF%BC%89%E2%80%94%E2%80%94runtime.Caller%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E5%90%8D%E5%92%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D%E3%80%81%E8%A1%8C%E5%8F%B7/</id>
    <published>2020-08-10T07:45:16.000Z</published>
    <updated>2022-07-31T09:22:30.134Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="runtime-Caller"><a href="#runtime-Caller" class="headerlink" title="runtime.Caller"></a>runtime.Caller</h2><p>函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Caller</span><span class="params">(skip <span class="type">int</span>)</span></span> (pc <span class="type">uintptr</span>, file <span class="type">string</span>, line <span class="type">int</span>, ok <span class="type">bool</span>)</span><br></pre></td></tr></table></figure><p><code>Caller</code>报告当前go程调用栈所执行的函数的文件和行号信息。实参<code>skip</code>为上溯的栈帧数，0表示<code>Caller</code>的调用者（<code>Caller</code>所在的调用栈）。函数的返回值为调用栈标识符、带路径的完整文件名、该调用在文件中的行号。如果无法获得信息，ok会被设为false。</p><h3 id="根据pc获取函数名"><a href="#根据pc获取函数名" class="headerlink" title="根据pc获取函数名"></a>根据pc获取函数名</h3><p>根据返回的调用栈标识符<code>pc</code>，我们可以获取对应的函数名。<br>需要用到一个函数和一个方法，签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncForPC</span><span class="params">(pc <span class="type">uintptr</span>)</span></span> *Func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Func)</span></span> Name</span><br></pre></td></tr></table></figure><p><code>FuncForPC</code>返回一个表示调用栈标识符<code>pc</code>对应的调用栈的<code>*Func</code>；如果该调用栈标识符没有对应的调用栈，函数会返回<code>nil</code>。每一个调用栈必然是对某个函数的调用。<br><code>Name</code>返回该调用栈所调用的函数的名字。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;path&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInfo</span><span class="params">(skip <span class="type">int</span>)</span></span> (funcName, fileName <span class="type">string</span>, lineNo <span class="type">int</span>) &#123;</span><br><span class="line">pc, file, lineNo, ok := runtime.Caller(skip)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;runtime.Caller() failed&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">funcName = runtime.FuncForPC(pc).Name()</span><br><span class="line">fileName = path.Base(file) <span class="comment">// Base函数返回路径的最后一个元素</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(getInfo(<span class="number">0</span>))</span><br><span class="line">fmt.Println(getInfo(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.getInfo main.<span class="keyword">go</span> <span class="number">10</span></span><br><span class="line">main.main main.<span class="keyword">go</span> <span class="number">22</span></span><br></pre></td></tr></table></figure><p>函数签名和函数作用均来自<a href="https://studygolang.com/pkgdoc">Go语言标准库文档中文版</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;runtime-Caller&quot;&gt;&lt;a href=&quot;#runtime-Caller&quot; class=&quot;headerlink&quot; title=&quot;runtime.Caller&quot;&gt;&lt;/a&gt;runtime.Caller&lt;/h2&gt;</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="go golang" scheme="http://website13.github.io/tags/go-golang/"/>
    
  </entry>
  
  <entry>
    <title>golang包的日常（2）——log包</title>
    <link href="http://website13.github.io/2020/08/09/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94log%E5%8C%85/"/>
    <id>http://website13.github.io/2020/08/09/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94log%E5%8C%85/</id>
    <published>2020-08-09T07:28:48.000Z</published>
    <updated>2022-07-31T09:22:23.559Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="普通使用"><a href="#普通使用" class="headerlink" title="普通使用"></a>普通使用</h2><p><code>log</code>包定义了<code>Logger</code>类型，该类型提供了一些格式化输出的方法。<br><code>log</code>包中预定义了一个标准<code>logger</code>对象<code>std</code>，使我们可以直接调用函数来打印日志，默认是标准错误输出（<code>Stderr</code>），打印到终端界面。当然也可以自定义创建<code>logger</code>对象，控制<code>std</code>所调用的所有函数在内部都是调用了同名的<code>logger</code>类型的方法。<br>函数包括：</p><ul><li><code>Print()</code>、<code>Printf()</code>、<code>Println()</code></li><li><code>Fatal()</code>、<code>Fatalf()</code>、<code>Fatalln()</code>：触发<code>fatal</code>，写入日志信息后调用<code>os.Exit(1)</code>，程序直接退出，不会调用defer</li><li><code>Panic</code>、<code>Panicf</code>、<code>Panicln</code>：触发<code>panic</code></li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log.Print(<span class="string">&quot;Print\n&quot;</span>)</span><br><span class="line">v := <span class="string">&quot;Printf&quot;</span></span><br><span class="line">log.Printf(<span class="string">&quot;%s\n&quot;</span>, v)</span><br><span class="line">log.Println(<span class="string">&quot;Println&quot;</span>)</span><br><span class="line">log.Fatalln(<span class="string">&quot;触发fatal&quot;</span>)</span><br><span class="line">log.Panicln(<span class="string">&quot;触发panic&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">13</span>:<span class="number">41</span>:<span class="number">18</span> Print</span><br><span class="line"><span class="number">2020</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">13</span>:<span class="number">41</span>:<span class="number">18</span> Printf</span><br><span class="line"><span class="number">2020</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">13</span>:<span class="number">41</span>:<span class="number">18</span> Println</span><br><span class="line"><span class="number">2020</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">13</span>:<span class="number">41</span>:<span class="number">18</span> 触发fatal</span><br></pre></td></tr></table></figure><p><code>log</code>包中预定义的<code>logger</code>对象默认会打印每条日志信息的日期、时间。例子中调用<code>Fatalln()</code>函数后，打印了日志信息，然后程序直接退出。</p><h2 id="配置logger"><a href="#配置logger" class="headerlink" title="配置logger"></a>配置logger</h2><p>当我们不满足于默认的日期和时间，就需要配置<code>logger</code>获得更多信息。<br><code>log</code>包中可以用<code>SetFlags()</code>函数来设置<code>std</code>的输出配置，然后可以用<code>Flags()</code>函数来返回<code>std</code>的输出配置。如果是自定义<code>logger</code>对象，也有同名方法可以使用，调用函数本质上是在内部用<code>std</code>调用同名方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Flags</span><span class="params">()</span></span> <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetFlags</span><span class="params">(flag <span class="type">int</span>)</span></span></span><br></pre></td></tr></table></figure><p><code>log</code>包为参数<code>flag</code>定义了一系列常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Ldate         = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>     <span class="comment">// the date in the local time zone: 2009/01/23</span></span><br><span class="line">Ltime                         <span class="comment">// the time in the local time zone: 01:23:23</span></span><br><span class="line">Lmicroseconds                 <span class="comment">// microsecond resolution: 01:23:23.123123.  assumes Ltime.</span></span><br><span class="line">Llongfile                     <span class="comment">// 文件全路径名 and line number: /a/b/c/d.go:23</span></span><br><span class="line">Lshortfile                    <span class="comment">// 文件名 and line number: d.go:23. 会覆盖Llongfile</span></span><br><span class="line">LUTC                          <span class="comment">// if Ldate or Ltime is set, use UTC rather than the local time zone</span></span><br><span class="line">Lmsgprefix                    <span class="comment">// move the &quot;prefix&quot; from the beginning of the line to before the message</span></span><br><span class="line">LstdFlags     = Ldate | Ltime <span class="comment">// initial values for the standard logger</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>LstdFlags</code>是标准<code>logger</code>对象<code>std</code>配置的初始值，下面是<code>std</code>的声明语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> std = New(os.Stderr, <span class="string">&quot;&quot;</span>, LstdFlags)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.SetFlags(log.Lshortfile | log.Lmicroseconds | log.Ldate)</span><br><span class="line">log.Println(<span class="string">&quot;配置之后的日志&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">14</span>:<span class="number">24</span>:<span class="number">52.532449</span> main.<span class="keyword">go</span>:<span class="number">17</span>: 配置之后的日志</span><br></pre></td></tr></table></figure><p>此时查看其输出配置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(log.Flags()) <span class="comment">// 13</span></span><br></pre></td></tr></table></figure><p>输出13是因为，<code>Llongfile</code>的值是<code>8</code>，<code>Lmicroseconds</code>的值是<code>4</code>，<code>Ldate</code>的值<code>1</code>，或运算后得到<code>13</code>。</p><h2 id="配置日志前缀"><a href="#配置日志前缀" class="headerlink" title="配置日志前缀"></a>配置日志前缀</h2><p>给输出的日志添加指定的前缀，有助于之后的信息检索。<br><code>log</code>包中可以用<code>SetPrefix()</code>函数来设置<code>std</code>的输出前缀，还可以用<code>Prefix()</code>函数查看<code>std</code>的输出前缀。如果是自定义<code>logger</code>对象，也有同名方法可以使用，调用函数本质上是在内部用<code>std</code>调用同名方法。</p><p>示例（<code>logger</code>配置接上例）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log.SetPrefix(<span class="string">&quot;[我是前缀]&quot;</span>)</span><br><span class="line">log.Println(<span class="string">&quot;带前缀的日志。&quot;</span>)</span><br><span class="line">fmt.Println(log.Prefix())</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[我是前缀]<span class="number">2020</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">05.437154</span> main.<span class="keyword">go</span>:<span class="number">20</span>: 带前缀的日志。</span><br><span class="line">[我是前缀]</span><br></pre></td></tr></table></figure><h2 id="配置日志输出位置"><a href="#配置日志输出位置" class="headerlink" title="配置日志输出位置"></a>配置日志输出位置</h2><p><code>log</code>包中可以用<code>SetOutput()</code>函数来设置<code>std</code>的输出目的地，默认是标准错误输出（<code>Stderr</code>）。如果是自定义<code>logger</code>对象，也有同名方法可以使用，调用函数本质上是在内部用<code>std</code>调用同名方法。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">logFile, err := os.OpenFile(<span class="string">&quot;t1.log&quot;</span>, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;open log file failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.SetOutput(logFile)</span><br><span class="line">log.SetFlags(log.Lshortfile | log.Lmicroseconds | log.Ldate)</span><br><span class="line">log.SetPrefix(<span class="string">&quot;[我是前缀]&quot;</span>)</span><br><span class="line">log.Println(<span class="string">&quot;我是日志。&quot;</span>)</span><br></pre></td></tr></table></figure><p>上例会将日志输出到同目录下的<code>t1.log</code>文件中。<br>文件中的输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[我是前缀]<span class="number">2020</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">15</span>:<span class="number">12</span>:<span class="number">25.340135</span> main.<span class="keyword">go</span>:<span class="number">31</span>: 我是日志。</span><br></pre></td></tr></table></figure><p>如果使用<code>std</code>，可以将配置操作写到<code>init()</code>函数中。</p><h2 id="自定义logger对象"><a href="#自定义logger对象" class="headerlink" title="自定义logger对象"></a>自定义logger对象</h2><p><code>log</code>包提供了<code>logger</code>对象的构造函数<code>New()</code>，格式如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(out io.Writer, prefix <span class="type">string</span>, flag <span class="type">int</span>)</span></span> *Logger</span><br></pre></td></tr></table></figure><p>参数依次是输出目的地、前缀、日志信息。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logger := log.New(os.Stderr, <span class="string">&quot;&lt;New&gt;&quot;</span>, log.Lshortfile|log.Ldate|log.Ltime)</span><br><span class="line">logger.Println(<span class="string">&quot;自定义logger日志。&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;New&gt;<span class="number">2020</span>/<span class="number">08</span>/<span class="number">09</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">17</span> main.<span class="keyword">go</span>:<span class="number">33</span>: 自定义logger日志。</span><br></pre></td></tr></table></figure><p><a href="https://www.liwenzhou.com/posts/Go/go_log/">参考</a><br><a href="https://github.com/sirupsen/logrus">第三方日志库logrus</a><br><a href="https://github.com/uber-go/zap">第三方日志库zap</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;普通使用&quot;&gt;&lt;a href=&quot;#普通使用&quot; class=&quot;headerlink&quot; title=&quot;普通使用&quot;&gt;&lt;/a&gt;普通使用&lt;/h2&gt;&lt;p&gt;&lt;code&gt;log&lt;/code&gt;包定义了&lt;code&gt;Logger&lt;/cod</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="go golang" scheme="http://website13.github.io/tags/go-golang/"/>
    
  </entry>
  
  <entry>
    <title>golang包的日常（1）——time包</title>
    <link href="http://website13.github.io/2020/08/08/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94time%E5%8C%85/"/>
    <id>http://website13.github.io/2020/08/08/golang%E5%8C%85%E7%9A%84%E6%97%A5%E5%B8%B8%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94time%E5%8C%85/</id>
    <published>2020-08-08T08:06:35.000Z</published>
    <updated>2022-07-31T09:22:22.488Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><p>时间类型：<code>time.Time</code><br>我们可以通过<code>time</code>包中的<code>Now</code>函数获取当前本地时间，然后使用时间类型的方法得到当前本地时间的年、月、日等信息。<br><code>Now()</code>函数格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// // Now returns the current local time.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Now</span><span class="params">()</span></span> Time</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)                     <span class="comment">// 2020-08-08 13:25:18.5419281 +0800 CST m=+0.001996701</span></span><br><span class="line">fmt.Println(<span class="string">&quot;年：&quot;</span>, now.Year())        <span class="comment">// 年： 2020</span></span><br><span class="line">fmt.Println(<span class="string">&quot;月：&quot;</span>, now.Month())       <span class="comment">// 月： August</span></span><br><span class="line">fmt.Println(<span class="string">&quot;日：&quot;</span>, now.Day())         <span class="comment">// 日： 8</span></span><br><span class="line">fmt.Println(<span class="string">&quot;小时：&quot;</span>, now.Hour())       <span class="comment">// 小时： 13</span></span><br><span class="line">fmt.Println(<span class="string">&quot;分钟：&quot;</span>, now.Minute())     <span class="comment">// 分钟： 25</span></span><br><span class="line">fmt.Println(<span class="string">&quot;秒：&quot;</span>, now.Second())      <span class="comment">// 秒： 18</span></span><br><span class="line">fmt.Println(<span class="string">&quot;纳秒：&quot;</span>, now.Nanosecond()) <span class="comment">// 纳秒： 541928100</span></span><br></pre></td></tr></table></figure><p>时间类型还有其它方法：<br><code>Date()</code>：返回年月日<br><code>Clock()</code>：返回时分秒<br>更多方法函数参考<a href="https://studygolang.com/pkgdoc">包文档中文版</a></p><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>时间戳是自1970年1月1日（08:00:00GMT）至当前时间的总毫秒数。它也被称为<code>Unix</code>时间戳（UnixTimestamp）。<br>获取时间戳：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">timestamp1 := now.Unix()     <span class="comment">//时间戳</span></span><br><span class="line">timestamp2 := now.UnixNano() <span class="comment">//纳秒时间戳</span></span><br><span class="line">fmt.Println(timestamp1, <span class="string">&quot;秒&quot;</span>)  <span class="comment">// 1596866180 秒</span></span><br><span class="line">fmt.Println(timestamp2, <span class="string">&quot;纳秒&quot;</span>) <span class="comment">// 1596866180018784800 纳秒</span></span><br></pre></td></tr></table></figure><p><code>time</code>包中的<code>Unix()</code>函数可以将时间戳转换为时间格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">timed := time.Unix(timestamp1, <span class="number">0</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;年：&quot;</span>, timed.Year())        <span class="comment">// 年： 2020</span></span><br><span class="line">fmt.Println(<span class="string">&quot;月：&quot;</span>, timed.Month())       <span class="comment">// 月： August</span></span><br><span class="line">fmt.Println(<span class="string">&quot;日：&quot;</span>, timed.Day())         <span class="comment">// 日： 8</span></span><br><span class="line">fmt.Println(<span class="string">&quot;小时：&quot;</span>, timed.Hour())       <span class="comment">// 小时： 14</span></span><br><span class="line">fmt.Println(<span class="string">&quot;分钟：&quot;</span>, timed.Minute())     <span class="comment">// 分钟： 7</span></span><br><span class="line">fmt.Println(<span class="string">&quot;秒：&quot;</span>, timed.Second())      <span class="comment">// 秒： 47</span></span><br><span class="line">fmt.Println(<span class="string">&quot;纳秒：&quot;</span>, timed.Nanosecond()) <span class="comment">// 纳秒： 0</span></span><br></pre></td></tr></table></figure><p>其中<code>Unix()</code>函数的格式是：<br><code>func Unix(sec int64, nsec int64) Time</code><br>其接收秒数和纳秒数，返回值是时间类型。</p><h2 id="时间间隔"><a href="#时间间隔" class="headerlink" title="时间间隔"></a>时间间隔</h2><p><code>time.Duration</code>是<code>time包</code>定义的一个类型（<code>type Duration int64</code>），它代表两个时间点之间经过的时间，以纳秒为单位。<br><code>time</code>包中定义了一些<code>Duration</code>类型的常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Nanosecond  Duration = <span class="number">1</span></span><br><span class="line">Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line">Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line">Second               = <span class="number">1000</span> * Millisecond</span><br><span class="line">Minute               = <span class="number">60</span> * Second</span><br><span class="line">Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(time.Second)      <span class="comment">// 1s</span></span><br><span class="line">fmt.Println(time.Microsecond) <span class="comment">// 1µs</span></span><br></pre></td></tr></table></figure><h2 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h2><h3 id="Add-方法"><a href="#Add-方法" class="headerlink" title="Add()方法"></a>Add()方法</h3><p>给当前时间增加一定的时间间隔，得到新的时间。如果传入的时间间隔是负的，则可以实现当前时间减去一定的时间间隔。<br>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add returns the time t+d.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Add(d Duration) Time</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now) <span class="comment">// 2020-08-08 14:34:46.3158009 +0800 CST m=+0.001981901</span></span><br><span class="line">later := now.Add(<span class="number">3</span>*time.Hour + time.Second) <span class="comment">// 当前时间增加3小时和1秒钟</span></span><br><span class="line">fmt.Println(later) <span class="comment">// 2020-08-08 17:34:47.3158009 +0800 CST m=+10801.001981901</span></span><br></pre></td></tr></table></figure><h3 id="Sub-方法"><a href="#Sub-方法" class="headerlink" title="Sub()方法"></a>Sub()方法</h3><p>返回两个时间的时间间隔。如果结果超出了时间间隔的范围，返回边界值。<br>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sub returns the duration t-u.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Sub(u Time) Duration</span><br></pre></td></tr></table></figure><p>示例（接上例）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">duration := later.Sub(now)</span><br><span class="line">fmt.Println(duration) <span class="comment">// 3h0m1s</span></span><br></pre></td></tr></table></figure><h3 id="Equal-方法"><a href="#Equal-方法" class="headerlink" title="Equal()方法"></a>Equal()方法</h3><p>判断两个时间是否相等，考虑时区的影响，例如，6:00 +0200和4:00 UTC相等。使用<code>==</code>比较两个时间不会考虑时区；大部分代码都会使用<code>Equal()</code>而不是<code>==</code>。<br>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Equal reports whether t and u represent the same time instant.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Equal(u Time) <span class="type">bool</span></span><br></pre></td></tr></table></figure><h3 id="Before-和After-方法"><a href="#Before-和After-方法" class="headerlink" title="Before()和After()方法"></a>Before()和After()方法</h3><p>判断时间先后。<br>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before reports whether the time instant t is before u.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Before(u Time) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// After reports whether the time instant t is after u.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> After(u Time) <span class="type">bool</span></span><br></pre></td></tr></table></figure><p>示例（接上例）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(later.Before(now)) <span class="comment">// false</span></span><br><span class="line">fmt.Println(later.After(now))  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>使用<code>time</code>包中的<code>Tick()</code>函数来设置定时器，定时器的本质上是一个通道（channel）。<br><code>Tick()</code>函数格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tick</span><span class="params">(d Duration)</span></span> &lt;-<span class="keyword">chan</span> Time</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ticker := time.Tick(time.Second) <span class="comment">//定义一个1秒间隔的定时器</span></span><br><span class="line"><span class="keyword">for</span> t := <span class="keyword">range</span> ticker &#123;</span><br><span class="line">fmt.Println(t) <span class="comment">//每秒都会执行的任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一定时间后部分输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-08</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">15.9648025</span> +<span class="number">0800</span> CST m=+<span class="number">1.012436201</span></span><br><span class="line"><span class="number">2020</span><span class="number">-08</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">16.9658258</span> +<span class="number">0800</span> CST m=+<span class="number">2.013459501</span></span><br><span class="line"><span class="number">2020</span><span class="number">-08</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">17.9650674</span> +<span class="number">0800</span> CST m=+<span class="number">3.012701101</span></span><br><span class="line"><span class="number">2020</span><span class="number">-08</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">18.9658949</span> +<span class="number">0800</span> CST m=+<span class="number">4.013528601</span></span><br><span class="line"><span class="number">2020</span><span class="number">-08</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">19.9660939</span> +<span class="number">0800</span> CST m=+<span class="number">5.013727601</span></span><br><span class="line"><span class="number">2020</span><span class="number">-08</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">20.9649029</span> +<span class="number">0800</span> CST m=+<span class="number">6.012536601</span></span><br><span class="line"><span class="number">2020</span><span class="number">-08</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">21.9653321</span> +<span class="number">0800</span> CST m=+<span class="number">7.012965801</span></span><br><span class="line"><span class="number">2020</span><span class="number">-08</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">22.9648979</span> +<span class="number">0800</span> CST m=+<span class="number">8.012531601</span></span><br><span class="line"><span class="number">2020</span><span class="number">-08</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">23.9646915</span> +<span class="number">0800</span> CST m=+<span class="number">9.012325201</span></span><br></pre></td></tr></table></figure><h2 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h2><p>时间类型有一个自带的方法<code>Format()</code>进行格式化，需要注意的是Go语言中格式化时间模板不是常见的<code>Y-m-d H:M:S</code>而是使用Go的诞生时间2006年1月2号15点04分05秒。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line"><span class="comment">// 24小时制</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006-01-02 15:04:05.000 Mon Jan&quot;</span>)) <span class="comment">// 2020-08-08 15:34:23.164 Sat Aug</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;Mon Jan 2006-01-02 15:04:05&quot;</span>)) <span class="comment">// Sat Aug 2020-08-08 15:34:23</span></span><br><span class="line"><span class="comment">// 12小时制，注意需要指定 PM</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006-01-02 03:04:05.000 PM&quot;</span>)) <span class="comment">// 2020-08-08 03:34:23.164 PM</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006/01/02 15:04&quot;</span>))           <span class="comment">// 2020/08/08 15:34</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;15:04 2006/01/02&quot;</span>))           <span class="comment">// 15:34 2020/08/08</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006/01/02&quot;</span>))                 <span class="comment">// 2020/08/08</span></span><br></pre></td></tr></table></figure><h3 id="解析格式化的时间"><a href="#解析格式化的时间" class="headerlink" title="解析格式化的时间"></a>解析格式化的时间</h3><p><code>time</code>包有两个函数可以解析字符串格式的时间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(layout, value <span class="type">string</span>)</span></span> (Time, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInLocation</span><span class="params">(layout, value <span class="type">string</span>, loc *Location)</span></span> (Time, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>Parse()</code>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> longForm = <span class="string">&quot;Jan 2, 2006 at 3:04pm (MST)&quot;</span></span><br><span class="line">t, _ := time.Parse(longForm, <span class="string">&quot;Feb 3, 2013 at 7:54pm (PST)&quot;</span>)</span><br><span class="line">fmt.Println(t) <span class="comment">// 2013-02-03 19:54:00 -0800 PST</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shortForm = <span class="string">&quot;2006-Jan-02&quot;</span></span><br><span class="line">t, _ = time.Parse(shortForm, <span class="string">&quot;2013-Feb-03&quot;</span>)</span><br><span class="line">fmt.Println(t) <span class="comment">// 2013-02-03 00:00:00 +0000 UTC</span></span><br></pre></td></tr></table></figure><p>对于<code>Parse()</code>函数，如果参数<code>value</code>带有时区信息，那么以<code>value</code>中的时区信息为准，否则默认时区是<code>UTC</code>。</p><p><code>ParseInLocation()</code>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">loc, _ := time.LoadLocation(<span class="string">&quot;Europe/Berlin&quot;</span>) <span class="comment">// 加载时区</span></span><br><span class="line"><span class="keyword">const</span> longForm = <span class="string">&quot;Jan 2, 2006 at 3:04pm (MST)&quot;</span></span><br><span class="line">t, _ := time.ParseInLocation(longForm, <span class="string">&quot;Jul 9, 2012 at 5:02am (CEST)&quot;</span>, loc)</span><br><span class="line">fmt.Println(t) <span class="comment">// 2012-07-09 05:02:00 +0200 CEST</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shortForm = <span class="string">&quot;2006-Jan-02&quot;</span></span><br><span class="line">t, _ = time.ParseInLocation(shortForm, <span class="string">&quot;2012-Jul-09&quot;</span>, loc)</span><br><span class="line">fmt.Println(t) <span class="comment">// 2012-07-09 00:00:00 +0200 CEST</span></span><br></pre></td></tr></table></figure><p>对于<code>ParseInLocation()</code>函数，时区以参数<code>loc</code>为准。</p><p><a href="https://www.liwenzhou.com/posts/Go/go_time/">参考1</a><br><a href="https://studygolang.com/pkgdoc">参考2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;时间类型&quot;&gt;&lt;a href=&quot;#时间类型&quot; class=&quot;headerlink&quot; title=&quot;时间类型&quot;&gt;&lt;/a&gt;时间类型&lt;/h2&gt;&lt;p&gt;时间类型：&lt;code&gt;time.Time&lt;/code&gt;&lt;br&gt;我们可以通过</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go" scheme="http://website13.github.io/tags/golang-go/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（18）——文件操作：文件开关、简单的读写实例、设置文件读写位置、文件删除、文件名重命名、文件操作相关方法/函数补充</title>
    <link href="http://website13.github.io/2020/08/07/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8818%EF%BC%89%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%EF%BC%9A%E6%96%87%E4%BB%B6%E5%BC%80%E5%85%B3%E3%80%81%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%BB%E5%86%99%E5%AE%9E%E4%BE%8B%E3%80%81%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E4%BD%8D%E7%BD%AE%E3%80%81%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E3%80%81%E6%96%87%E4%BB%B6%E5%90%8D%E9%87%8D%E5%91%BD%E5%90%8D%E3%80%81%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95!%E5%87%BD%E6%95%B0%E8%A1%A5%E5%85%85/"/>
    <id>http://website13.github.io/2020/08/07/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8818%EF%BC%89%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%EF%BC%9A%E6%96%87%E4%BB%B6%E5%BC%80%E5%85%B3%E3%80%81%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%BB%E5%86%99%E5%AE%9E%E4%BE%8B%E3%80%81%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E4%BD%8D%E7%BD%AE%E3%80%81%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E3%80%81%E6%96%87%E4%BB%B6%E5%90%8D%E9%87%8D%E5%91%BD%E5%90%8D%E3%80%81%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95!%E5%87%BD%E6%95%B0%E8%A1%A5%E5%85%85/</id>
    <published>2020-08-07T05:00:33.000Z</published>
    <updated>2022-07-31T09:22:28.869Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="文件打开和关闭"><a href="#文件打开和关闭" class="headerlink" title="文件打开和关闭"></a>文件打开和关闭</h2><p><code>os</code>包中<code>Open</code>函数能够以只读方式打开一个文件，函数返回<code>*File</code>和<code>err</code>。打开的文件可以通过调用<code>Close</code>方法关闭。<br><code>Open</code>函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="type">string</span>)</span></span> (*File, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>Open</code>函数接收文件路径，返回一个文件指针和可能的具体错误。<br><code>Close</code>方法签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(file *File)</span></span> Close() <span class="type">error</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;open file failed!, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭文件，配合defer能防止忘记关闭</span></span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><h3 id="Read方法"><a href="#Read方法" class="headerlink" title="Read方法"></a>Read方法</h3><p>签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>Read</code>方法接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回<code>0</code>和<code>io.EOF</code>（需要导入<code>io</code>包）。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">file, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;open file failed!, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="comment">// 循环读取文件</span></span><br><span class="line"><span class="keyword">var</span> content []<span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">128</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := file.Read(tmp)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;read file failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">content = <span class="built_in">append</span>(content, tmp[:n]...)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bufio按行读取"><a href="#bufio按行读取" class="headerlink" title="bufio按行读取"></a>bufio按行读取</h3><p>需要导入<code>bufio</code>包。<br>按行读取示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;open file failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="comment">// 新建一个缓冲区，把内容先放在缓冲区</span></span><br><span class="line">reader := bufio.NewReader(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 遇到&#x27;\n&#x27;则结束读取，读取内容包括&#x27;\n&#x27;</span></span><br><span class="line">line, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 注意是字符</span></span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(line) != <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(line)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;read file failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(line)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中用到了<code>bufio</code>包中的一个函数和一个方法。<br><code>NewReader</code>函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span></span> *Reader</span><br></pre></td></tr></table></figure><p><code>NewReader</code>函数会新建一个默认大小的缓冲区，把文件内容先放在缓冲区，返回该缓冲区指针。其参数是一个接口，当接收文件指针时，可以读取文件内容；当接收<code>io.Stdin</code>时，从标准输入生成读对象。</p><p><code>ReadString()</code>方法签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> ReadString(delim <span class="type">byte</span>) (<span class="type">string</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>ReadString</code>方法接收的是一个字符，每次读取到这个字符为止，包括该字符。所以当传入<code>\n</code>时，就可以实现一次读取一行。其返回值是读取的字符串和可能的具体错误。</p><h3 id="ioutil一次性读取整个文件"><a href="#ioutil一次性读取整个文件" class="headerlink" title="ioutil一次性读取整个文件"></a>ioutil一次性读取整个文件</h3><p>需要导入<code>io/ioutil</code>包。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">content, err := ioutil.ReadFile(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;read file failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReadFile</code>函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>ReadFile</code>函数接收文件路径，返回包含整个文件的字节切片和可能的具体错误。</p><h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><p><code>os.OpenFile</code>函数能够以指定模式打开文件，从而实现文件写入相关功能。<br>签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (*File, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><ul><li><code>name</code>：文件路径</li><li><code>flag</code>：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.</span></span><br><span class="line">O_RDONLY <span class="type">int</span> = syscall.O_RDONLY <span class="comment">// open the file read-only.</span></span><br><span class="line">O_WRONLY <span class="type">int</span> = syscall.O_WRONLY <span class="comment">// open the file write-only.</span></span><br><span class="line">O_RDWR   <span class="type">int</span> = syscall.O_RDWR   <span class="comment">// open the file read-write.</span></span><br><span class="line"><span class="comment">// The remaining values may be or&#x27;ed in to control behavior.</span></span><br><span class="line">O_APPEND <span class="type">int</span> = syscall.O_APPEND <span class="comment">// append data to the file when writing.</span></span><br><span class="line">O_CREATE <span class="type">int</span> = syscall.O_CREAT  <span class="comment">// create a new file if none exists.</span></span><br><span class="line">O_EXCL   <span class="type">int</span> = syscall.O_EXCL   <span class="comment">// used with O_CREATE, file must not exist.</span></span><br><span class="line">O_SYNC   <span class="type">int</span> = syscall.O_SYNC   <span class="comment">// open for synchronous I/O.</span></span><br><span class="line">O_TRUNC  <span class="type">int</span> = syscall.O_TRUNC  <span class="comment">// truncate regular writable file when opened.</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>perm</code>：文件权限，一个八进制数。<code>r</code>（读）04，<code>w</code>（写）02，<code>x</code>（执行）01</li></ul><h3 id="Write和WriteString"><a href="#Write和WriteString" class="headerlink" title="Write和WriteString"></a>Write和WriteString</h3><p>直接将内容写入文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := os.OpenFile(<span class="string">&quot;t1.txt&quot;</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;open file failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">str := <span class="string">&quot;hello 浙江\n&quot;</span></span><br><span class="line">file.Write([]<span class="type">byte</span>(str))      <span class="comment">// 写入字节切片数据</span></span><br><span class="line">file.WriteString(<span class="string">&quot;hello 杭州&quot;</span>) <span class="comment">// 直接写入字符串数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Write()</code>方法签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Write(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>Write</code>方法接收一个字节切片，返回值是字节切片长度和可能的具体错误。</p><p><code>WriteString</code>方法签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> WriteString(s <span class="type">string</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> f.Write([]<span class="type">byte</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>WriteString</code>函数就是将传入的字符串转换成字节切片，再调用<code>Write</code>方法，返回值相同。</p><h3 id="bufio-NewWriter"><a href="#bufio-NewWriter" class="headerlink" title="bufio.NewWriter"></a>bufio.NewWriter</h3><p>将数据先写入缓冲区，写完后一次性将缓冲区中的内容写入文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := os.OpenFile(<span class="string">&quot;t1.txt&quot;</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;open file failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">writer := bufio.NewWriter(file)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">writer.WriteString(<span class="string">&quot;hello中国&quot;</span> + strconv.Itoa(i) + <span class="string">&quot;\n&quot;</span>) <span class="comment">// 将数据先写入缓存</span></span><br><span class="line">&#125;</span><br><span class="line">writer.Flush() <span class="comment">// 将缓存中的内容写入文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewWriter</code>函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(w io.Writer)</span></span> *Writer</span><br></pre></td></tr></table></figure><p><code>NewWriter</code>函数会新建一个默认大小的缓冲区，返回该缓冲区指针。</p><p><code>WriteString</code>方法签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span></span> WriteString(s <span class="type">string</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>WriteString</code>方法接收一个字符串，返回已经写入的字节数，如果写入字节数&lt; <code>len(s)</code>，返回具体的错误。</p><p><code>Flush()</code>方法：将缓冲区的内容写入文件。</p><h3 id="ioutil-WriteFile"><a href="#ioutil-WriteFile" class="headerlink" title="ioutil.WriteFile"></a>ioutil.WriteFile</h3><p>将内容直接写入文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">`</span></span><br><span class="line"><span class="string">hello 中国</span></span><br><span class="line"><span class="string">hello 浙江</span></span><br><span class="line"><span class="string">hello 杭州`</span></span><br><span class="line">err := ioutil.WriteFile(<span class="string">&quot;t1.txt&quot;</span>, []<span class="type">byte</span>(str), <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;write file failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WriteFile</code>函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(filename <span class="type">string</span>, data []<span class="type">byte</span>, perm os.FileMode)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure><h2 id="其它文件操作方法-x2F-函数补充"><a href="#其它文件操作方法-x2F-函数补充" class="headerlink" title="其它文件操作方法&#x2F;函数补充"></a>其它文件操作方法&#x2F;函数补充</h2><h3 id="Seek方法设置文件读写位置"><a href="#Seek方法设置文件读写位置" class="headerlink" title="Seek方法设置文件读写位置"></a>Seek方法设置文件读写位置</h3><p>签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Seek(offset <span class="type">int64</span>, whence <span class="type">int</span>) (ret <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>Seek()</code>方法能设置下一次读&#x2F;写的位置。<code>offset</code>为相对偏移量，而<code>whence</code>决定相对位置：0为相对文件开头，1为相对当前位置，2为相对文件结尾。它返回新的偏移量（相对开头）和可能的错误。</p><h3 id="os-Rename函数重命名文件"><a href="#os-Rename函数重命名文件" class="headerlink" title="os.Rename函数重命名文件"></a>os.Rename函数重命名文件</h3><p>注意：使用前需要关闭文件。<br>签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Rename</span><span class="params">(oldpath, newpath <span class="type">string</span>)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.Rename(<span class="string">&quot;./t1.txt&quot;</span>, <span class="string">&quot;./t2.txt&quot;</span>)</span><br></pre></td></tr></table></figure><p>示例中将文件名<code>t1.txt</code>改为<code>t2.txt</code>，重命名的过程中利用<code>newpath</code>还可以移动文件位置。</p><h3 id="os-Remove函数删除文件-x2F-目录"><a href="#os-Remove函数删除文件-x2F-目录" class="headerlink" title="os.Remove函数删除文件&#x2F;目录"></a>os.Remove函数删除文件&#x2F;目录</h3><p>注意：使用前需要关闭文件。<br>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure><p><code>Remove()</code>函数能删除<code>name</code>指定的文件或目录。如果出错，会返回<code>*PathError</code>底层类型的错误。</p><h3 id="path-Join函数路径拼接"><a href="#path-Join函数路径拼接" class="headerlink" title="path.Join函数路径拼接"></a>path.Join函数路径拼接</h3><p>签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(elem ...<span class="type">string</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure><p>Join函数可以将任意数量的路径元素放入一个单一路径里，会根据需要添加斜杠。结果是经过简化的，所有的空字符串元素会被忽略。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(path.Join(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)) <span class="comment">// a/b/c</span></span><br></pre></td></tr></table></figure><h3 id="查看文件信息：名字、大小、模式位等"><a href="#查看文件信息：名字、大小、模式位等" class="headerlink" title="查看文件信息：名字、大小、模式位等"></a>查看文件信息：名字、大小、模式位等</h3><p>查看文件信息可以用<code>os.Stat</code>函数，也可以打开文件后，使用<code>(*File).Stat</code>方法。</p><p>函数签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stat</span><span class="params">(name <span class="type">string</span>)</span></span> (fi FileInfo, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>Stat</code>返回一个描述<code>name</code>指定的文件对象的<code>FileInfo</code>。如果指定的文件对象是一个符号链接，返回的<code>FileInfo</code>描述该符号链接指向的文件的信息，本函数会尝试跳转该链接。如果出错，返回的错误值为<code>*PathError</code>类型。</p><p>方法签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Stat() (fi FileInfo, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>Stat</code>返回描述文件<code>f</code>的<code>FileInfo</code>类型值。如果出错，错误底层类型是<code>*PathError</code>。</p><p>两者的返回值相同，我们可以通过返回的<code>FileInfo</code>类型值得到文件的相关信息。<br><code>FileInfo</code>类型声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FileInfo用来描述一个文件对象。</span></span><br><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="type">string</span>       <span class="comment">// 文件的名字（不含扩展名）</span></span><br><span class="line">    Size() <span class="type">int64</span>        <span class="comment">// 普通文件返回值表示其大小；其他文件的返回值含义各系统不同</span></span><br><span class="line">    Mode() FileMode     <span class="comment">// 文件的模式位</span></span><br><span class="line">    ModTime() time.Time <span class="comment">// 文件的修改时间</span></span><br><span class="line">    IsDir() <span class="type">bool</span>        <span class="comment">// 等价于Mode().IsDir()</span></span><br><span class="line">    Sys() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// 底层数据来源（可以返回nil）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 使用os.Stat函数获取FileInfo值</span></span><br><span class="line">fileInfo, err := os.Stat(<span class="string">&quot;main.go&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(fileInfo.Name(), fileInfo.Size()) <span class="comment">// main.go 356</span></span><br><span class="line"><span class="comment">// 使用Stat方法获取FileInfo值</span></span><br><span class="line">file, err := os.Open(<span class="string">&quot;main.go&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">fileInfo, err = file.Stat()</span><br><span class="line">fmt.Println(fileInfo.Name(), fileInfo.Size()) <span class="comment">// main.go 356</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://studygolang.com/pkgdoc">更多函数&#x2F;方法可查中文版包文档</a><br><a href="https://www.liwenzhou.com/posts/Go/go_file/">参考</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;文件打开和关闭&quot;&gt;&lt;a href=&quot;#文件打开和关闭&quot; class=&quot;headerlink&quot; title=&quot;文件打开和关闭&quot;&gt;&lt;/a&gt;文件打开和关闭&lt;/h2&gt;&lt;p&gt;&lt;code&gt;os&lt;/code&gt;包中&lt;code&gt;Op</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go" scheme="http://website13.github.io/tags/golang-go/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（17）——包（package）：自定义包、标识符可见性、导入、init()函数、简单实例</title>
    <link href="http://website13.github.io/2020/08/06/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8817%EF%BC%89%E2%80%94%E2%80%94%E5%8C%85%EF%BC%88package%EF%BC%89%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E3%80%81%E6%A0%87%E8%AF%86%E7%AC%A6%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%AF%BC%E5%85%A5%E3%80%81init()%E5%87%BD%E6%95%B0%E3%80%81%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"/>
    <id>http://website13.github.io/2020/08/06/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8817%EF%BC%89%E2%80%94%E2%80%94%E5%8C%85%EF%BC%88package%EF%BC%89%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E3%80%81%E6%A0%87%E8%AF%86%E7%AC%A6%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%AF%BC%E5%85%A5%E3%80%81init()%E5%87%BD%E6%95%B0%E3%80%81%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/</id>
    <published>2020-08-06T06:00:41.000Z</published>
    <updated>2022-07-31T09:22:27.877Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="定义包"><a href="#定义包" class="headerlink" title="定义包"></a>定义包</h2><p>一个包可以简单理解为一个存放<code>.go</code>文件的文件夹。这些<code>go</code>文件都归属于该包，通过在代码第一行声明实现。声明格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>一个包下面的所有文件只能归属于同一个包。</li><li>包名可以和文件夹名不同，包名不能包含<code>-</code>符号。</li><li><code>main</code>包是应用程序的入口包，只有<code>main</code>包才会在编译后生成可执行文件。</li></ul><h2 id="包中标识符的对外可见性"><a href="#包中标识符的对外可见性" class="headerlink" title="包中标识符的对外可见性"></a>包中标识符的对外可见性</h2><p>标识符包括变量、常量、类型、函数等，还有结构体中的字段名、接口中的方法名，Go语言中只要将标识符的首字母大写，就可以让该标识符对外可见。</p><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><p>使用<code>import</code>关键字导入需要使用的包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;包名&quot;</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>导入语句通常放在包声明语句的下面。</li><li>导入的包名需要用双引号包裹。</li><li>对于自定义的包，导入时需要加路径。（如果设置了GOPATH，包名是从<code>$GOPATH/src/</code>后开始计算的，使用<code>/</code>进行路径分隔）</li><li>禁止循环导入包</li></ul><h3 id="单行导入"><a href="#单行导入" class="headerlink" title="单行导入"></a>单行导入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;包1&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;包2&quot;</span></span><br></pre></td></tr></table></figure><h3 id="多行导入"><a href="#多行导入" class="headerlink" title="多行导入"></a>多行导入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;包1&quot;</span></span><br><span class="line"><span class="string">&quot;包2&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="导入时自定义包名"><a href="#导入时自定义包名" class="headerlink" title="导入时自定义包名"></a>导入时自定义包名</h2><p>导入包时可以自定义别名，通常用于包名太长（带路径时名字往往很长）或包名冲突时。<br>用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 别名 <span class="string">&quot;包名&quot;</span></span><br></pre></td></tr></table></figure><p>当不需要使用包中的数据时，可以匿名导入（比如只需要执行包中的<code>init()函数</code>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;包名&quot;</span></span><br></pre></td></tr></table></figure><h2 id="init-初始化函数"><a href="#init-初始化函数" class="headerlink" title="init()初始化函数"></a>init()初始化函数</h2><p>在Go语言程序执行时导入包语句会自动触发包内部<code>init()</code>函数的调用。需要注意的是： <code>init()</code>函数没有参数也没有返回值。 <code>init()</code>函数在程序运行时自动被调用执行，不能在代码中主动调用它。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;自动执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;先执行init()函数&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自动执行</span><br><span class="line">先执行init()函数</span><br></pre></td></tr></table></figure><h3 id="包中init-函数执行时机"><a href="#包中init-函数执行时机" class="headerlink" title="包中init()函数执行时机"></a>包中init()函数执行时机</h3><p>全局声明-&gt;<code>init()</code>函数-&gt;<code>main()</code>函数</p><h3 id="所有init-函数执行顺序"><a href="#所有init-函数执行顺序" class="headerlink" title="所有init()函数执行顺序"></a>所有init()函数执行顺序</h3><p>程序编译时，从<code>main</code>包开始检查导入的包，其中导入的包中可能还导入了其它包。最终可以构建树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。运行时，最后导入的包最先初始化并调用其<code>init()</code>函数。</p><h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h2><p>自定义一个<code>calc</code>包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> calc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// init()函数可以不写，这里是为了体现其执行顺序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;执行calc包的init()函数&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 两数求和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>calc</code>包中<code>Add()</code>函数首字母大写，使其对其它包可见。<br>然后在<code>main</code>包中导入<code>calc</code>包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">calc <span class="string">&quot;xxxx/xxx/xxx/xxx/03calc&quot;</span> <span class="comment">// 使用别名</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// init()函数可以不写，这里是为了体现其执行顺序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;执行main包的init()函数&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(calc.Add(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>calc</code>包文件在文件夹”03calc”下，如果文件夹名和包名相同，可以不取别名，否则需要取别名，别名可以和包名相同。<br>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行calc包的init()函数</span><br><span class="line">执行main包的init()函数</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>calc</code>包后导入，其<code>init()</code>函数先执行。</p><p><a href="https://www.liwenzhou.com/posts/Go/11_package/">参考</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;定义包&quot;&gt;&lt;a href=&quot;#定义包&quot; class=&quot;headerlink&quot; title=&quot;定义包&quot;&gt;&lt;/a&gt;定义包&lt;/h2&gt;&lt;p&gt;一个包可以简单理解为一个存放&lt;code&gt;.go&lt;/code&gt;文件的文件夹。这些&lt;c</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go" scheme="http://website13.github.io/tags/golang-go/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（16）——接口（interface）：基本概念、接口嵌套、空接口、类型断言（获取接口底层值）</title>
    <link href="http://website13.github.io/2020/08/04/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8816%EF%BC%89%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97%E3%80%81%E7%A9%BA%E6%8E%A5%E5%8F%A3%E3%80%81%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%EF%BC%88%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%80%BC%EF%BC%89/"/>
    <id>http://website13.github.io/2020/08/04/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8816%EF%BC%89%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97%E3%80%81%E7%A9%BA%E6%8E%A5%E5%8F%A3%E3%80%81%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%EF%BC%88%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%E5%BA%95%E5%B1%82%E5%80%BC%EF%BC%89/</id>
    <published>2020-08-04T13:22:01.000Z</published>
    <updated>2022-07-31T09:22:53.142Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Go语言中<code>接口(interface)</code>是一种类型，一种抽象的类型。<code>接口类型</code>是由一组方法签名定义的集合。<br>接口的定义格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口类型名：自定义，一般会在后面添加<code>er</code>，表明接口类型</li><li>方法名首字母和接口类型名首字母都大写时，该方法可以被其他包访问</li><li>参数列表和返回值列表中可以省略变量名，只保留类型名</li></ul><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>其它类型只要实现了一个接口的所有方法，那么就实现了这个接口。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个包含say()方法的接口</span></span><br><span class="line"><span class="keyword">type</span> sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dog类型实现say()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> say() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;汪~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat类型实现say()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span></span> say() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;喵~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a sayer</span><br><span class="line">a = dog&#123;&#125;</span><br><span class="line">a.say() <span class="comment">// 汪~</span></span><br><span class="line">a = cat&#123;&#125;</span><br><span class="line">a.say() <span class="comment">// 喵~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口类型变量可以存储所有实现该接口的类型变量。上例中，接口类型变量<code>a</code>既可以存储<code>dog</code>类型变量，又可以存储<code>cat</code>类型变量，因为<code>dog</code>和<code>cat</code>类型都实现了该接口的所有方法。<br>有了接口，所有拥有相同方法的自定义类型都可以抽象的用接口类型表示，那么在代码中，如果要对这些自定义类型变量进行相同的操作，就不需要逐个定义和操作，只需要定义一个接口类型变量和操作，就可以适用于所有实现该接口的类型变量。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> say() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;汪~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cat)</span></span> say() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;喵~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">speak</span><span class="params">(s sayer)</span></span> &#123;</span><br><span class="line">s.say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d := &amp;dog&#123;&#125;</span><br><span class="line">c := &amp;cat&#123;&#125;</span><br><span class="line">speak(d) <span class="comment">// 汪~</span></span><br><span class="line">speak(c) <span class="comment">// 喵~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中的<code>speak</code>函数以接口类型变量作为参数，所有实现该接口的类型变量都可以使用该函数，减少了代码的冗余。</p><h3 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h3><ul><li>接口也是值。它们可以像其它值一样传递。</li><li>接口值可以用作函数的参数或返回值。</li><li>在内部，接口值可以看做包含值和具体类型的元组：<code>(value, type)</code>。接口类型变量还未赋值时，<code>value</code>和<code>type</code>都是<code>nil</code>。</li><li>接口值保存了一个具体底层类型的具体值。</li><li>接口值调用方法时会执行其底层类型的同名方法。</li></ul><p>示例接上例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a sayer</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v, %T\n&quot;</span>, a, a) <span class="comment">// &lt;nil&gt;, &lt;nil&gt;</span></span><br><span class="line">a = &amp;dog&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v, %T\n&quot;</span>, a, a) <span class="comment">// &amp;&#123;&#125;, *main.dog</span></span><br></pre></td></tr></table></figure><h2 id="方法中使用值接收者和指针接收者的区别"><a href="#方法中使用值接收者和指针接收者的区别" class="headerlink" title="方法中使用值接收者和指针接收者的区别"></a>方法中使用值接收者和指针接收者的区别</h2><h3 id="值接收者"><a href="#值接收者" class="headerlink" title="值接收者"></a>值接收者</h3><p>接着上例，<code>dog</code>类型的<code>say</code>方法使用的是值接收者，尝试分别用值类型和指针类型的<code>dog</code>类型值给接口类型变量赋值，结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a sayer</span><br><span class="line">a = dog&#123;&#125;</span><br><span class="line">a.say() <span class="comment">// 汪~</span></span><br><span class="line">a = &amp;dog&#123;&#125;</span><br><span class="line">a.say() <span class="comment">// 汪~</span></span><br></pre></td></tr></table></figure><p>可以发现，使用值接收者时，值类型和指针类型的<code>dog</code>类型值都可以赋值给接口变量。这是因为Go语言在编译时会自动给指针求值。</p><h3 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h3><p>还是上例，将<code>cat</code>类型的<code>say</code>方法改成使用指针接收者：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cat)</span></span> say() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;喵~&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试分别用值类型和指针类型的<code>cat</code>类型值给接口类型变量赋值，结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &amp;cat&#123;&#125; <span class="comment">// 正常接收</span></span><br><span class="line">a.say()    <span class="comment">// 喵~</span></span><br><span class="line">a = cat&#123;&#125;  <span class="comment">// 不能接收</span></span><br><span class="line">a.say()</span><br></pre></td></tr></table></figure><p>可以发现，使用指针接收者时，只能使用指针类型的<code>cat</code>类型值给接口类型变量赋值。</p><h2 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a>类型与接口的关系</h2><ul><li>一个类型可以实现多个接口。因为一个类型只要实现一个接口的所有方法，就实现了这个接口。</li><li>多个类型实现同一接口。上面的例子中，<code>dog</code>类型和<code>cat</code>类型都实现了<code>sayer</code>接口的所有方法，所以它们都实现了<code>sayer</code>接口。<br>通过嵌套匿名结构体可以让结构体”继承”匿名结构体的方法（详情见<a href="https://blog.csdn.net/m0_37710023/article/details/107657413">golang基础小记（14）</a>中的嵌套结构体），那么一个接口的方法，不一定需要由一个类型完全实现，而可以通过在类型中嵌入其他类型或者结构体来实现。</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现washingMachine接口需要实现wash()和dry()接口</span></span><br><span class="line"><span class="keyword">type</span> washingMachine <span class="keyword">interface</span> &#123;</span><br><span class="line">wash()</span><br><span class="line">dry()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dryer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dryer类型实现了dry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dryer)</span></span> dry() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;甩一甩&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// haier类型嵌套了匿名结构体，此时haier类型拥有了dryer类型的dry()方法</span></span><br><span class="line"><span class="keyword">type</span> haier <span class="keyword">struct</span> &#123;</span><br><span class="line">dryer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// haier类型实现了wash()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h haier)</span></span> wash() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;洗刷刷&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := haier&#123;dryer&#123;&#125;&#125;</span><br><span class="line"><span class="comment">// 可以看到haier类型的变量能够直接使用dryer类型的dry()方法</span></span><br><span class="line">a.dry() <span class="comment">// 甩一甩</span></span><br><span class="line"><span class="keyword">var</span> b washingMachine</span><br><span class="line"><span class="comment">// 因为haier类型能直接使用dry()方法和wash()方法，所以其实现了washingMachine接口</span></span><br><span class="line">b = a</span><br><span class="line">b.dry() <span class="comment">// 甩一甩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，对于接口来说，一个类型如何实现该接口需要的所有方法并不重要，只要该类型变量可以直接使用这些方法，那么这个类型就实现了该接口。</p><h2 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h2><p>直接给例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> washer <span class="keyword">interface</span> &#123;</span><br><span class="line">wash()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// washingMachine接口嵌套了washer接口</span></span><br><span class="line"><span class="keyword">type</span> washingMachine <span class="keyword">interface</span> &#123;</span><br><span class="line">washer</span><br><span class="line">dry()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dryer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dryer)</span></span> dry() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;甩一甩&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dryer)</span></span> wash() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;洗刷刷&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := dryer&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b washingMachine</span><br><span class="line">b = a <span class="comment">// dryer类型实现了washingMachine接口</span></span><br><span class="line">b.dry()  <span class="comment">// 甩一甩</span></span><br><span class="line">b.wash() <span class="comment">// 洗刷刷</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口可以嵌套接口，那么如果一个类型想实现这个接口，不仅要实现该接口包含的方法，也要实现嵌套接口包含的方法。比如一堆类型既实现了<code>a</code>接口，又实现了<code>b</code>接口，这时就可以利用接口嵌套创造新的接口<code>c</code>，其嵌套了<code>a</code>接口和<code>b</code>接口，那么这堆类型的变量就都可以用接口<code>c</code>类型的变量来存储了。</p><h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>指定了零个方法的接口被称为空接口。<br>格式：<code>interface &#123;&#125;</code><br>空接口可以保存任何类型的值。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyer <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a emptyer</span><br><span class="line">a = <span class="string">&quot;爱中国&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %v\n&quot;</span>, a, a) <span class="comment">// string 爱中国</span></span><br><span class="line">a = <span class="number">15</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %v\n&quot;</span>, a, a) <span class="comment">// int 15</span></span><br><span class="line">a = <span class="literal">true</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %v\n&quot;</span>, a, a) <span class="comment">// bool true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用1——作为函数参数"><a href="#应用1——作为函数参数" class="headerlink" title="应用1——作为函数参数"></a>应用1——作为函数参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// show函数可以接收任意类型的参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(e <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %v\n&quot;</span>, e, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">15</span></span><br><span class="line">show(a) <span class="comment">// int 15</span></span><br><span class="line">b := <span class="literal">false</span></span><br><span class="line">show(b) <span class="comment">// bool false</span></span><br><span class="line">c := <span class="string">&quot;爱中国&quot;</span></span><br><span class="line">show(c) <span class="comment">// string 爱中国</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用2——作为map的值"><a href="#应用2——作为map的值" class="headerlink" title="应用2——作为map的值"></a>应用2——作为map的值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m的值可以是任意类型</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="number">3</span>)</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="literal">true</span></span><br><span class="line">m[<span class="number">3</span>] = <span class="string">&quot;爱中国&quot;</span></span><br><span class="line">m[<span class="number">4</span>] = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(m) <span class="comment">// map[1:5 2:true 3:爱中国 4:[1 2 3]]</span></span><br></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p><code>类型断言</code>提供了访问接口底层具体值的方式。<br>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v := i.(T)</span><br></pre></td></tr></table></figure><p>该语句断言接口类型变量 <code>i</code>保存了具体类型 <code>T</code>，并将其底层类型为 <code>T</code>的值赋予变量<code>v</code>。若<code>i</code>并未保存 <code>T</code>类型的值，该语句就会触发一个<code>panic</code>。<br>如果不想触发<code>panic</code>，需要让<code>类型断言</code>返回两个值：底层值以及报告断言是否成功的布尔值。<br>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := i.(T)</span><br></pre></td></tr></table></figure><p>若<code>i</code>保存了一个 <code>T</code>，那么 <code>v</code>将会是其底层值，而 <code>ok</code>为 <code>true</code>。<br>否则，<code>ok</code> 将为<code>false</code>而<code>v</code> 将为 <code>T</code> 类型的零值，程序并不会产生<code>panic</code>。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e是空接口类型变量，让其存储一个string类型的值</span></span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">e = <span class="string">&quot;爱中国&quot;</span></span><br><span class="line">v1, ok1 := e.(<span class="type">string</span>) <span class="comment">// 断言底层类型是string类型</span></span><br><span class="line">fmt.Println(v1, ok1)  <span class="comment">// 爱中国 true</span></span><br><span class="line">v2, ok2 := e.(<span class="type">int</span>)    <span class="comment">// 断言底层类型是int类型</span></span><br><span class="line">fmt.Println(v2, ok2)  <span class="comment">// 0 false</span></span><br></pre></td></tr></table></figure><p>可以用<code>switch</code>实现多次断言：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">e = <span class="string">&quot;爱中国&quot;</span></span><br><span class="line"><span class="comment">// .(type)只能用在switch中</span></span><br><span class="line"><span class="keyword">switch</span> v := e.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;x is a string，value is %v\n&quot;</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;x is a int is %v\n&quot;</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;x is a bool is %v\n&quot;</span>, v)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;unsupport type！&quot;</span>)</span><br><span class="line">&#125; <span class="comment">// x is a string，value is 爱中国</span></span><br></pre></td></tr></table></figure><p><a href="https://tour.go-zh.org/methods/11">参考1</a><br><a href="https://www.liwenzhou.com/posts/Go/12_interface/">参考2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go" scheme="http://website13.github.io/tags/golang-go/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（15）——方法（Method）</title>
    <link href="http://website13.github.io/2020/07/30/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8815%EF%BC%89%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%EF%BC%88Method%EF%BC%89/"/>
    <id>http://website13.github.io/2020/07/30/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8815%EF%BC%89%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%EF%BC%88Method%EF%BC%89/</id>
    <published>2020-07-30T09:27:01.000Z</published>
    <updated>2022-07-31T09:22:51.978Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><code>方法（Method）</code>就是一类带特殊的<code>接收者（Receiver）</code>参数的函数。其与函数的区别在于，函数不属于任何类型，方法属于特定的类型。<br>定义格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span></span> 方法名(参数) 返回值 &#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给myInt类型添加方法，判断值是否大于5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i myInt)</span></span> biggerThanFive() <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">5</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a myInt</span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="comment">// myInt类型的方法只有myInt类型的变量才能使用</span></span><br><span class="line">fmt.Println(a.biggerThanFive()) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：非本地类型不能定义方法<br>基本类型（int、string）等不是本地类型，不能直接定义方法，但我们可以自定义类型，如上例中的<code>myInt</code>，这样就可以为<code>myInt</code>类型添加方法，而且<code>myInt</code>具有<code>int</code>类型的特性。</p><h2 id="接收者参数"><a href="#接收者参数" class="headerlink" title="接收者参数"></a>接收者参数</h2><p>接收者参数可以是值类型，也可以是指针类型。区别在于指针类型，可以在方法中修改变量本身，而值类型只能修改变量副本，不会对变量本身产生影响。<br>以结构体为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line">size, price <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收者变量名一般用类型名首字母的小写</span></span><br><span class="line"><span class="comment">// 接收者参数是值类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h house)</span></span> f1(newSize <span class="type">int</span>) &#123;</span><br><span class="line">h.size = newSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收者参数是指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *house)</span></span> f2(newSize <span class="type">int</span>) &#123;</span><br><span class="line">h.size = newSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h1 := house&#123;</span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="number">150</span>,</span><br><span class="line">&#125;</span><br><span class="line">h1.f1(<span class="number">120</span>) <span class="comment">// 这里可以是h1，也可以是(&amp;h1)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, h1) <span class="comment">// main.house&#123;size:100, price:150&#125;</span></span><br><span class="line">h1.f2(<span class="number">150</span>) <span class="comment">// 这里可以是h1，也可以是(&amp;h1)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v&quot;</span>, h1) <span class="comment">// main.house&#123;size:150, price:150&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，调用<code>f1</code>方法后，变量<code>h1</code>没有被修改；调用<code>f2</code>方法后，变量<code>h1</code>被修改。<br>不管接收者参数是什么类型，方法被调用时，接收者既能为值又能为指针。</p><h3 id="什么时候使用指针类型接收者"><a href="#什么时候使用指针类型接收者" class="headerlink" title="什么时候使用指针类型接收者"></a>什么时候使用指针类型接收者</h3><ol><li>需要修改接收者变量</li><li>拷贝接收者变量的开销较大</li><li>保证一致性，一个方法用了，其他的也用指针类型接收者</li></ol><p><a href="https://www.liwenzhou.com/posts/Go/10_struct/">参考1</a><br><a href="https://tour.go-zh.org/methods/4">参考2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h2&gt;&lt;p&gt;&lt;code&gt;方法（Method）&lt;/code&gt;就是一类带特殊的&lt;code&gt;接收者（Rece</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go" scheme="http://website13.github.io/tags/golang-go/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（14）——结构体：定义、初始化、构造函数、匿名字段、嵌套结构体、JSON序列化与反序列化</title>
    <link href="http://website13.github.io/2020/07/29/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8814%EF%BC%89%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A%E5%AE%9A%E4%B9%89%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5%E3%80%81%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81JSON%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://website13.github.io/2020/07/29/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8814%EF%BC%89%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A%E5%AE%9A%E4%B9%89%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5%E3%80%81%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81JSON%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2020-07-29T12:13:11.000Z</published>
    <updated>2022-07-31T09:22:50.800Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><p>Go语言没有类的概念，但是可以通过结构体实现面向对象编程。<br>结构体是一种自定义数据类型，其可以封装任何类型。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line">size, price <span class="type">float64</span></span><br><span class="line">style <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例<code>house</code>是自定义结构体类型，包括<code>size</code>、<code>price</code>、<code>style</code>三个字段，可以用来描述房子的面积、价格和风格。<code>house</code>类型的变量可以很方便的存储房子信息。</p><h2 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a>结构体实例化</h2><p>结构体是值类型，需要声明后才能使用，声明后内部成员的值默认是对应成员类型的零值。</p><h3 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a>基本实例化</h3><p>使用上面定义的<code>house</code>举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> h1 house</span><br><span class="line">h1.size = <span class="number">130</span></span><br><span class="line">h1.style = <span class="string">&quot;中国风&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, h1) <span class="comment">// &#123;130 0 中国风&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v&quot;</span>, h1)  <span class="comment">// main.house&#123;size:130, price:0, style:&quot;中国风&quot;&#125;</span></span><br><span class="line">fmt.Println(h1.size)   <span class="comment">// 130</span></span><br></pre></td></tr></table></figure><p>通过<code>.</code>来访问结构体的字段（成员变量）</p><h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><p>匿名结构体可以用来定义临时结构体。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> family <span class="keyword">struct</span> &#123;</span><br><span class="line">Mom <span class="type">string</span></span><br><span class="line">Dad <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">family.Mom = <span class="string">&quot;Mommy&quot;</span></span><br><span class="line">family.Dad = <span class="string">&quot;Daddy&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, family)  <span class="comment">// &#123;Mommy Daddy&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, family) <span class="comment">// struct &#123; Mom string; Dad string &#125;&#123;Mom:&quot;Mommy&quot;, Dad:&quot;Daddy&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>上例中<code>family</code>是<code>struct &#123; Mom string; Dad string &#125;</code>类型的变量，因为没有用<code>type</code>关键字定义名字，每次使用都得写清楚结构体类型。</p><h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><ol><li><pre><code>使用`new`关键字</code></pre></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1 := <span class="built_in">new</span>(house)</span><br><span class="line">p1.style = <span class="string">&quot;欧式&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1) <span class="comment">// &amp;main.house&#123;size:0, price:0, style:&quot;欧式&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>Go语言中支持对结构体指针直接使用<code>.</code>来访问结构体的成员。在访问的时候编译器会自动把 <code>p1.style</code> 转为 <code>(*p1).style</code>。</p><ol start="2"><li><pre><code>使用取地址符`&amp;`</code></pre></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p2 := &amp;house&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p2)  <span class="comment">// *main.house</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p2) <span class="comment">// &amp;main.house&#123;size:0, price:0, style:&quot;&quot;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h2><h3 id="直接声明"><a href="#直接声明" class="headerlink" title="直接声明"></a>直接声明</h3><p>成员默认初始化为对应类型的零值。比如之前例子中的<code>var h1 house</code>。</p><h3 id="利用键值对初始化"><a href="#利用键值对初始化" class="headerlink" title="利用键值对初始化"></a>利用键值对初始化</h3><p>（1）对结构体进行键值对初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h3 := house&#123;</span><br><span class="line">size:  <span class="number">110</span>,</span><br><span class="line">price: <span class="number">700</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, h3) <span class="comment">// main.house&#123;size:110, price:700, style:&quot;&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>没必要对每一个成员都设置初始值，未设置初始值的默认为对应类型的零值。<br>（2）对结构体指针进行键值对初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p3 := &amp;house&#123;</span><br><span class="line">size:  <span class="number">110</span>,</span><br><span class="line">price: <span class="number">700</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p3) <span class="comment">// &amp;main.house&#123;size:110, price:700, style:&quot;&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>（3）值的列表初始化<br>也就是初始化的时候省略键，只写值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h4 := house&#123;</span><br><span class="line"><span class="number">110</span>,</span><br><span class="line"><span class="number">940</span>,</span><br><span class="line"><span class="string">&quot;中国风&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, h4) <span class="comment">// main.house&#123;size:110, price:940, style:&quot;中国风&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>需要注意：省略键后，所有成员的值都需要初始化，且顺序要和结构体定义顺序相同。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>Go语言没有结构体的构造函数，但可以手动实现。实现构造函数后可以十分方便的构造结构体变量。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line">size, price <span class="type">float64</span></span><br><span class="line">style       <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回结构体指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newHouse</span><span class="params">(size, price <span class="type">float64</span>, style <span class="type">string</span>)</span></span> *house &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;house&#123;</span><br><span class="line">size:  size,</span><br><span class="line">price: price,</span><br><span class="line">style: style,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := newHouse(<span class="number">100</span>, <span class="number">80</span>, <span class="string">&quot;中国风&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1) <span class="comment">// &amp;main.house&#123;size:100, price:80, style:&quot;中国风&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中的<code>newHouse</code>函数就是一个构造函数，可以用来构造<code>house</code>类型的结构体。构造函数可以返回结构体，也可以返回结构体指针。当结构体比较大的时候，返回结构体会有较大的值拷贝性能开销，这时返回结构体指针更合适。</p><h2 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h2><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为<code>匿名字段</code>。<code>匿名字段</code>默认会采用类型名作为字段名，而结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h1 := house&#123;</span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="string">&quot;中国风&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, h1)        <span class="comment">// main.house&#123;int:100, string:&quot;中国风&quot;&#125;</span></span><br><span class="line">fmt.Println(h1.<span class="type">string</span>, h1.<span class="type">int</span>) <span class="comment">// 中国风 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名字段也可以与非匿名字段混用，示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">height <span class="type">int</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">name <span class="type">string</span></span><br><span class="line"><span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := person&#123;</span><br><span class="line">height: <span class="number">178</span>,</span><br><span class="line"><span class="type">int</span>:    <span class="number">100</span>,</span><br><span class="line">name:   <span class="string">&quot;夏静怡&quot;</span>,</span><br><span class="line"><span class="type">string</span>: <span class="string">&quot;篮球&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1)                   <span class="comment">// main.person&#123;height:178, int:100, name:&quot;夏静怡&quot;, string:&quot;篮球&quot;&#125;</span></span><br><span class="line">fmt.Println(p1.height, p1.<span class="type">int</span>, p1.<span class="type">string</span>) <span class="comment">// 178 100 篮球</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h2><p>嵌套结构体就是一个结构体中包含另一个结构体或结构体指针。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">province, city <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line">size <span class="type">int</span></span><br><span class="line">addr address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h1 := house&#123;</span><br><span class="line">size: <span class="number">100</span>,</span><br><span class="line">addr: address&#123;</span><br><span class="line"><span class="string">&quot;浙江&quot;</span>,</span><br><span class="line"><span class="string">&quot;杭州&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, h1)   <span class="comment">// main.house&#123;size:100, addr:main.address&#123;province:&quot;浙江&quot;, city:&quot;杭州&quot;&#125;&#125;</span></span><br><span class="line"><span class="comment">// 嵌套结构体的成员可以通过&#x27;.&#x27;一层一层的访问</span></span><br><span class="line">fmt.Println(h1.addr.city) <span class="comment">// 杭州</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当嵌套结构体采用匿名字段的方式，其成员可以直接访问。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">province, city <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line">size <span class="type">int</span></span><br><span class="line">address <span class="comment">// 匿名嵌套结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h1 := house&#123;</span><br><span class="line">size: <span class="number">100</span>,</span><br><span class="line">address: address&#123;</span><br><span class="line"><span class="string">&quot;浙江&quot;</span>,</span><br><span class="line"><span class="string">&quot;杭州&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, h1)               <span class="comment">// main.house&#123;size:100, address:main.address&#123;province:&quot;浙江&quot;, city:&quot;杭州&quot;&#125;&#125;</span></span><br><span class="line"><span class="comment">// 匿名字段可以省略</span></span><br><span class="line">fmt.Println(h1.address.city, h1.city) <span class="comment">// 杭州 杭州</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当访问结构体成员时会先在结构体中查找该字段，找不到再去嵌套的匿名字段中查找。嵌套可以多层嵌套，中途的匿名字段都可以省略。<br>注意：如果嵌套结构体内部有相同字段，那么匿名字段也不可省略。<br>模拟“继承”：外层结构体能够使用匿名嵌套结构体的方法。（Go语言没有继承的概念，但可以利用结构体模拟实现）</p><h2 id="结构体字段可见性"><a href="#结构体字段可见性" class="headerlink" title="结构体字段可见性"></a>结构体字段可见性</h2><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p><h2 id="JSON序列化和反序列化"><a href="#JSON序列化和反序列化" class="headerlink" title="JSON序列化和反序列化"></a>JSON序列化和反序列化</h2><p><a href="http://json.cn/">JSON在线解析及格式化验证网站</a></p><h3 id="JSON序列化"><a href="#JSON序列化" class="headerlink" title="JSON序列化"></a>JSON序列化</h3><p>结构体–&gt;JSON格式的字符串。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span> <span class="comment">// 引入json包</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line">Size  <span class="type">int</span>  <span class="comment">// 字段名首字母必须大写，否则json包访问不到字段数据</span></span><br><span class="line">Style <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h1 := house&#123;</span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="string">&quot;中国风&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">data, err := json.Marshal(h1) <span class="comment">// 序列化函数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;json marshal failed&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, data) <span class="comment">// &#123;&quot;Size&quot;:100,&quot;Style&quot;:&quot;中国风&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：当结构体需要被其他包访问时，结构体字段（成员）名首字母必须大写</p><h3 id="JSON反序列化"><a href="#JSON反序列化" class="headerlink" title="JSON反序列化"></a>JSON反序列化</h3><p>JSON格式的字符串–&gt;结构体。<br>字符串中可以没有结构体的字段名，此时该字段值是对应类型的零值。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line">Size  <span class="type">int</span></span><br><span class="line">Style <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">`&#123;&quot;Size&quot;:100,&quot;Style&quot;:&quot;中国风&quot;&#125;`</span> <span class="comment">// JSON格式的字符串</span></span><br><span class="line"><span class="keyword">var</span> h2 house</span><br><span class="line"><span class="comment">// 反序列化函数，参数是[]byte类型的JSON格式字符串和结构体指针（因为要对结构体变量进行修改）</span></span><br><span class="line">err = json.Unmarshal([]<span class="type">byte</span>(str), &amp;h2)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;json unmarshal failed!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, h2) <span class="comment">// main.house&#123;Size:100, Style:&quot;中国风&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体标签（Tag）"><a href="#结构体标签（Tag）" class="headerlink" title="结构体标签（Tag）"></a>结构体标签（Tag）</h3><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。<code>Tag</code>在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`key1:&quot;value1&quot; key2:&quot;value2&quot;`</span></span><br></pre></td></tr></table></figure><p>结构体<code>Tag</code>由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。<br>注意：同一个键值对之间不能加空格<br>在JSON序列化时，由于结构体字段名首字母必须大写，可能无法满足字段名首字母小写的需求，这时就需要使用<code>Tag</code>。示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span> <span class="comment">// 引入json包</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> house <span class="keyword">struct</span> &#123;</span><br><span class="line">Size  <span class="type">int</span>    <span class="string">`json:&quot;size&quot;`</span></span><br><span class="line">Style <span class="type">string</span> <span class="string">`json:&quot;style&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h1 := house&#123;</span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="string">&quot;中国风&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">data, err := json.Marshal(h1) <span class="comment">// 序列化函数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;json marshal failed&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, data) <span class="comment">// &#123;&quot;size&quot;:100,&quot;style&quot;:&quot;中国风&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到JSON序列化后的字符串中，字段名首字母是小写的。<br><a href="https://www.liwenzhou.com/posts/Go/10_struct/">参考1</a><br><a href="https://www.cnblogs.com/wdliu/p/9209419.html">参考2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;结构体定义&quot;&gt;&lt;a href=&quot;#结构体定义&quot; class=&quot;headerlink&quot; title=&quot;结构体定义&quot;&gt;&lt;/a&gt;结构体定义&lt;/h2&gt;&lt;p&gt;Go语言没有类的概念，但是可以通过结构体实现面向对象编程。&lt;br&gt;</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go" scheme="http://website13.github.io/tags/golang-go/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（13）——自定义类型和类型别名(type)</title>
    <link href="http://website13.github.io/2020/07/29/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8813%EF%BC%89%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D(type)/"/>
    <id>http://website13.github.io/2020/07/29/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8813%EF%BC%89%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D(type)/</id>
    <published>2020-07-29T01:49:04.000Z</published>
    <updated>2022-07-31T09:22:49.647Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>Go语言通过<code>type</code>关键字定义自定义类型。自定义类型是全新的类型。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将newInt定义为int类型</span></span><br><span class="line"><span class="keyword">type</span> newInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a newInt</span><br><span class="line">a = <span class="number">100</span></span><br><span class="line">fmt.Println(a)        <span class="comment">// 100</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, a) <span class="comment">// main.newInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中的<code>newInt</code>是具有<code>int</code>特性的新类型。可以看到变量<code>a</code>的类型是<code>main.newInt</code>，这表示<code>main</code>包下定义的<code>newInt</code>类型。</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>语法格式：<code>type 别名 = Type</code><br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tempString = <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s tempString</span><br><span class="line">s = <span class="string">&quot;我是s&quot;</span></span><br><span class="line">fmt.Println(s)        <span class="comment">// 我是s</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, s) <span class="comment">// string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，<code>tempString</code>是<code>string</code>的别名，其本质上与<code>string</code>是同一个类型。类型别名只会在代码中存在，编译完成后不会有如<code>tempString</code>一样的类型别名。所以变量<code>s</code>的类型是<code>string</code>。<br>字符类型中的<code>byte</code>和<code>rune</code>就是类型别名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">byte</span> = <span class="type">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">rune</span> = <span class="type">int32</span></span><br></pre></td></tr></table></figure><p><a href="https://www.liwenzhou.com/posts/Go/10_struct/">参考</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;自定义类型&quot;&gt;&lt;a href=&quot;#自定义类型&quot; class=&quot;headerlink&quot; title=&quot;自定义类型&quot;&gt;&lt;/a&gt;自定义类型&lt;/h2&gt;&lt;p&gt;Go语言通过&lt;code&gt;type&lt;/code&gt;关键字定义自定义类型</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="go golang" scheme="http://website13.github.io/tags/go-golang/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（12）——defer</title>
    <link href="http://website13.github.io/2020/07/26/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8812%EF%BC%89%E2%80%94%E2%80%94defer/"/>
    <id>http://website13.github.io/2020/07/26/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8812%EF%BC%89%E2%80%94%E2%80%94defer/</id>
    <published>2020-07-26T08:18:12.000Z</published>
    <updated>2022-07-31T09:22:48.573Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a><code>defer</code>语句</h2><p>Go语言中的<code>defer</code>语句会将其后面跟随的函数推迟到外层函数返回之后执行。推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。推迟的函数调用会被压入一个栈中，当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。<br><code>defer</code>语句后面只能跟函数调用。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">1</span></span><br><span class="line">b := <span class="number">2</span></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">1</span>, a + b) <span class="comment">// 推迟的函数参数会立即赋值，后续改变参数值不会影响结果</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 该函数没有参数，如果函数内部使用了外层函数的变量，那么外层函数改变变量值会对结果产生影响</span></span><br><span class="line">fmt.Println(<span class="number">2</span>, a) <span class="comment">// 这里 a == 2</span></span><br><span class="line">&#125;()</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">3</span>, a + b) <span class="comment">// 后推迟的语句先输出结果</span></span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">end</span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>由于<code>defer</code>语句延迟调用的特性，所以<code>defer</code>语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。</p><h2 id="defer执行时机"><a href="#defer执行时机" class="headerlink" title="defer执行时机"></a><code>defer</code>执行时机</h2><ol><li>对返回值进行赋值</li><li>执行<code>defer</code>语句</li><li>执行RET指令（函数返回）</li></ol><p>这里需要区分一下函数返回值命名和不命名的情况。当返回值命名时，<code>defer</code>语句可以对返回值进行修改，在判断返回值时需要注意<code>defer</code>语句；当返回值没有命名时，<code>defer</code>语句不会影响返回值。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="comment">// 返回值无命名</span></span><br><span class="line">x := <span class="number">300</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">x = <span class="number">100</span> <span class="comment">// 此时x=300早就赋值给了返回值，这里只是改变x的值，与返回值无关</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">()</span></span> (x <span class="type">int</span>) &#123; <span class="comment">//返回值有命名</span></span><br><span class="line">x = <span class="number">300</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">x = <span class="number">100</span> <span class="comment">// 这里的x就是返回值，改变x就是直接改变返回值，如果改为x++，返回值为301</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test3</span><span class="params">()</span></span> (x <span class="type">int</span>) &#123;</span><br><span class="line">x = <span class="number">300</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> &#123; </span><br><span class="line">x = <span class="number">100</span> <span class="comment">// 这里的x作为函数的参数，与返回值x不是同一个参数，所以对返回值没有影响</span></span><br><span class="line">&#125;(x)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(test1()) <span class="comment">// 300</span></span><br><span class="line">fmt.Println(test2()) <span class="comment">// 100</span></span><br><span class="line">fmt.Println(test3()) <span class="comment">// 300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(index <span class="type">string</span>, a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">ret := a + b</span><br><span class="line">fmt.Println(index, a, b, ret)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">x := <span class="number">1</span></span><br><span class="line">y := <span class="number">2</span></span><br><span class="line"><span class="keyword">defer</span> calc(<span class="string">&quot;AA&quot;</span>, x, calc(<span class="string">&quot;A&quot;</span>, x, y))</span><br><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">defer</span> calc(<span class="string">&quot;BB&quot;</span>, x, calc(<span class="string">&quot;B&quot;</span>, x, y))</span><br><span class="line">y = <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">B <span class="number">10</span> <span class="number">2</span> <span class="number">12</span></span><br><span class="line">BB <span class="number">10</span> <span class="number">12</span> <span class="number">22</span></span><br><span class="line">AA <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>因为<code>defer</code>语句推迟的函数的参数会立即求值，所以第一句<code>defer</code>语句先计算<code>x</code>和<code>calc(&quot;A&quot;, x, y)</code>，传入的<code>x = 1, y = 2</code>，第二句同理，只是传入的<code>x</code>的值变成了10。<br><a href="https://www.liwenzhou.com/posts/Go/09_function/">参考1</a>、<a href="https://tour.go-zh.org/flowcontrol/12">参考2</a>、<a href="https://www.jianshu.com/p/67e40938d6b2">参考3</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;defer语句&quot;&gt;&lt;a href=&quot;#defer语句&quot; class=&quot;headerlink&quot; title=&quot;defer语句&quot;&gt;&lt;/a&gt;&lt;code&gt;defer&lt;/code&gt;语句&lt;/h2&gt;&lt;p&gt;Go语言中的&lt;code&gt;</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="go golang" scheme="http://website13.github.io/tags/go-golang/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（11）——函数基础、高阶函数、匿名函数、闭包、内置函数简介</title>
    <link href="http://website13.github.io/2020/07/25/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8811%EF%BC%89%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80%E3%80%81%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E3%80%81%E9%97%AD%E5%8C%85%E3%80%81%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B/"/>
    <id>http://website13.github.io/2020/07/25/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8811%EF%BC%89%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80%E3%80%81%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E3%80%81%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E3%80%81%E9%97%AD%E5%8C%85%E3%80%81%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B/</id>
    <published>2020-07-25T08:30:07.000Z</published>
    <updated>2022-07-31T09:22:46.670Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><p>语法格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数)</span></span>(返回值) &#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>参数由参数变量和对应类型组成，多个参数用<code>,</code>分隔。</li><li>Go语言中函数没有默认参数</li><li>类型简写：当连续两个或多个函数的参数类型相同时，除最后一个类型以外，其它都可以省略。比如参数<code>x int, y int</code>可以写成<code>x, y int</code>。</li><li>可变参数：当参数数量不固定时，可以通过在参数名后加<code>...</code>来标识可变参数。可变参数在函数中通过切片来实现。可变参数必须放在固定参数的后面。示例如下：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum2</span><span class="params">(x ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">fmt.Println(x) <span class="comment">// [1 2 3 4 5]</span></span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := sum2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(sum) <span class="comment">// 15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>Go语言通过<code>return</code>关键字输出返回值，且支持多返回值。</p><h3 id="返回值无命名"><a href="#返回值无命名" class="headerlink" title="返回值无命名"></a>返回值无命名</h3><p>单返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125; <span class="comment">// 调用时直接返回3</span></span><br></pre></td></tr></table></figure><p>多返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>, <span class="string">&quot;多返回值&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多返回值的接收方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b := test2()</span><br><span class="line">fmt.Println(a, b) <span class="comment">// 3 多返回值</span></span><br></pre></td></tr></table></figure><p>上面的<code>a</code>和<code>b</code>是自定义的变量名，用来接收返回值，不想接收某个值时可以用<code>_</code>代替变量名。</p><h3 id="返回值有命名"><a href="#返回值有命名" class="headerlink" title="返回值有命名"></a>返回值有命名</h3><p>返回值有命名时可以直接用<code>return</code>返回，当然写上变量名也没有关系。<br>命名的返回值可以直接使用，不需要再声明。<br>命名的多返回值如果类型相同，也可以类型简写。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test3</span><span class="params">()</span></span> (a <span class="type">int</span>, b <span class="type">string</span>) &#123;</span><br><span class="line">a = <span class="number">3</span></span><br><span class="line">b = <span class="string">&quot;有命名&quot;</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用后得到结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b := test3()</span><br><span class="line">fmt.Println(a, b) <span class="comment">// 3 有命名</span></span><br></pre></td></tr></table></figure><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>Go语言中函数也是一种类型，也就是说可以声明函数类型的变量，并为其赋值。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1 := add              <span class="comment">// 将函数add赋值给变量f1</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, f1) <span class="comment">// func(int, int) int</span></span><br><span class="line">fmt.Println(f1(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以使用<code>type</code>关键字定义一个函数类型，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure><p>这定义了一个<code>f</code>类型，是一种函数类型。<br>接上例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f2 f <span class="comment">// 声明一个f类型的变量f2</span></span><br><span class="line">f2 = add <span class="comment">// 这里add的类型必须与f类型相同，包括参数和返回值</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, f2) <span class="comment">// main.f</span></span><br><span class="line">fmt.Println(f2(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>高阶函数，将函数作为参数或者返回值。</p><h3 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f2的参数op是函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(x, y <span class="type">int</span>, op <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> op(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f2(<span class="number">2</span>, <span class="number">3</span>, add)) <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用f4会返回add函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f4</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> add</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f4()(<span class="number">4</span>, <span class="number">5</span>)) <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>匿名函数就是没有名字的函数。在函数内部只能定义匿名函数。匿名函数没有函数名，不能通过函数名调用，但可以作为返回值返回、可以保存到变量，通过变量来调用、还可以作为立即执行函数。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名函数作为返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f6</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x * y</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 保存到变量</span></span><br><span class="line">f5 := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(f5(<span class="number">3</span>, <span class="number">5</span>))   <span class="comment">// 8</span></span><br><span class="line">fmt.Println(f6()(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123; <span class="comment">// 立即执行函数</span></span><br><span class="line">fmt.Println(x - y) <span class="comment">// 3</span></span><br><span class="line">&#125;(<span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包是一个函数，这个函数包含了它外部作用域的变量。<br>闭包简单的、通用的定义是指：函数引用一个词法变量，在函数或语句块结束后(变量的名称消失)，词法变量仍然对引用它的函数有效。示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">// 返回一个闭包</span></span><br><span class="line">x = x + y</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1 := f(<span class="number">1</span>) <span class="comment">// f1是一个闭包，它引用了函数f中的变量x，在f在函数返回后退出，x这个名称也随之消失，但是x的值仍旧存在，直到f1被消除</span></span><br><span class="line">fmt.Println(f1(<span class="number">2</span>)) <span class="comment">// 3</span></span><br><span class="line">fmt.Println(f1(<span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line">f2 := f(<span class="number">3</span>) <span class="comment">// f2也是一个闭包，但是它引用的变量x和f1是相互独立的，这是闭包的特性</span></span><br><span class="line">fmt.Println(f2(<span class="number">2</span>)) <span class="comment">// 5</span></span><br><span class="line">fmt.Println(f2(<span class="number">3</span>)) <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包更严格的定义：闭包是一种在支持一级函的编程语言中能够将词法作用域中的变量名称进行绑定的技术。在操作上，闭包是一种用于保存函数和环境的记录。这个环境记录了一些关联性的映射，将函数的每个自由变量与创建闭包时所绑定名称的值或引用相关联。通过闭包，就算是在作用域外部调用函数，也允许函数通过闭包拷贝他们的值或通过引用的方式去访问那些已经被捕获的变量。<br>总之，要牢记<code>闭包</code>=<code>函数</code>+<code>引用环境</code>。</p><h1 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h1><ol><li><code>close</code>：主要用于关闭<code>channel</code></li><li><code>len</code>：求长度，如<code>map</code>、<code>slice</code>、<code>string</code>、<code>array</code>、<code>channel</code></li><li><code>new</code>：分配值类型的内存，如<code>int</code>、<code>struct</code>，返回对应类型的指针（<a href="https://blog.csdn.net/m0_37710023/article/details/107559760">用法</a>）</li><li><code>make</code>：分配引用类型的内存，如<code>map</code>、<code>slice</code>、<code>channel</code>，返回类型本身（<a href="https://blog.csdn.net/m0_37710023/article/details/107559760">用法</a>）</li><li><code>append</code>：<code>slice</code>、<code>array</code>追加元素（<a href="https://blog.csdn.net/m0_37710023/article/details/107529211">用法</a>）</li><li><code>panic/recover</code>：错误处理</li></ol><h3 id="panic-recover"><a href="#panic-recover" class="headerlink" title="panic/recover"></a><code>panic/recover</code></h3><p>Go语言使用<code>panic/recover</code>机制来处理错误。程序出错时会引发<code>panic</code>，导致程序直接异常退出，这会造成占用的资源无法释放（比如打开的文件）。对应的<code>recover</code>能解决这个问题，使程序恢复运行。<br>注意：</p><ul><li><code>recover</code>必须搭配<code>defer</code>使用</li><li><code>defer</code>一定要在引发<code>panic</code>之前定义<br>  示例：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;第一步&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;第二步出错&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;第三步&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1()</span><br><span class="line">f2()</span><br><span class="line">f3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一步</span><br><span class="line"><span class="built_in">panic</span>: 第二步出错</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.f2(...)</span><br><span class="line">e:/<span class="keyword">go</span>/src/github.com/BattleL/studygo/test/main.<span class="keyword">go</span>:<span class="number">17</span></span><br><span class="line">main.main()</span><br><span class="line">e:/<span class="keyword">go</span>/src/github.com/BattleL/studygo/test/main.<span class="keyword">go</span>:<span class="number">25</span> +<span class="number">0x9d</span></span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure><p>可以看到引发<code>panic</code>后程序直接退出，不会再往下运行。<br>修改函数<code>f2</code>，加入<code>recover</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// defer放在触发panic的语句之前</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := <span class="built_in">recover</span>() <span class="comment">// 如果程序没有出现panic，返回nil</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;继续运行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;第二步出错&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出变为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一步</span><br><span class="line">继续运行</span><br><span class="line">第三步</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到程序继续往下运行了。<br><a href="https://www.liwenzhou.com/posts/Go/09_function/">整体参考</a>、<a href="https://www.cnblogs.com/f-ck-need-u/p/9735955.html#%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E9%97%AD%E5%8C%85">闭包参考</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;函数基础&quot;&gt;&lt;a href=&quot;#函数基础&quot; class=&quot;headerlink&quot; title=&quot;函数基础&quot;&gt;&lt;/a&gt;函数基础&lt;/h1&gt;&lt;p&gt;语法格式：&lt;/p&gt;
&lt;figure class=&quot;highlight go</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang go" scheme="http://website13.github.io/tags/golang-go/"/>
    
  </entry>
  
  <entry>
    <title>golang基础小记（10）——map</title>
    <link href="http://website13.github.io/2020/07/25/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8810%EF%BC%89%E2%80%94%E2%80%94map/"/>
    <id>http://website13.github.io/2020/07/25/golang%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0%EF%BC%8810%EF%BC%89%E2%80%94%E2%80%94map/</id>
    <published>2020-07-25T04:07:35.000Z</published>
    <updated>2022-07-31T09:22:45.572Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>语法：<code>map[keyType]valueType</code></li><li>用于存储键值对（key-value），键具有唯一性</li><li>内部的键值对之间是无序的，和存入的顺序无关</li><li>引用类型，声明后值为<code>nil</code>，此时无法添加键值对，需要先使用<code>make()</code>来分配内存（使用方式见<a href="https://blog.csdn.net/m0_37710023/article/details/107559760">基础小记（9）</a>）</li><li>获取长度，即键值对个数：<code>len(map)</code></li><li>切片的元素类型可以是<code>map</code>，如<code>[]map[string]string</code>。此时要注意每个元素都需要用<code>make()</code>初始化</li><li><code>map</code>的值可以是切片，如<code>map[string][]string</code></li></ul><h2 id="添加键值对"><a href="#添加键值对" class="headerlink" title="添加键值对"></a>添加键值对</h2><h3 id="声明时填充"><a href="#声明时填充" class="headerlink" title="声明时填充"></a>声明时填充</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line"><span class="string">&quot;年龄&quot;</span>: <span class="number">25</span>,</span><br><span class="line"><span class="string">&quot;身高&quot;</span>: <span class="number">130</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m1[<span class="string">&quot;年龄&quot;</span>]) <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><p>如果输出时选择的键不存在，则输出对应类型的零值。</p><h3 id="直接添加"><a href="#直接添加" class="headerlink" title="直接添加"></a>直接添加</h3><p>向上例的<code>m1</code>添加键值对：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m1[<span class="string">&quot;体重&quot;</span>] = <span class="number">300</span></span><br><span class="line">m1[<span class="string">&quot;身高&quot;</span>] = <span class="number">150</span></span><br><span class="line">fmt.Println(m1) <span class="comment">// map[体重:300 年龄:25 身高:150]</span></span><br></pre></td></tr></table></figure><p>可以看到，如果<code>key</code>在原map中不存在，就添加新的键值对；如果已存在，就改变对应的<code>value</code>。</p><h2 id="判断键是否存在"><a href="#判断键是否存在" class="headerlink" title="判断键是否存在"></a>判断键是否存在</h2><p>语法格式：<code>value, ok := map[key]</code></p><ul><li><code>value</code>：如果键存在则返回对应值，否则返回对应类型的零值</li><li><code>ok</code>：如果键存在则返回<code>true</code>，否则返回<code>false</code></li></ul><p>接上例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v1, k1 := m1[<span class="string">&quot;身高&quot;</span>]</span><br><span class="line">v2, k2 := m1[<span class="string">&quot;爱好&quot;</span>]</span><br><span class="line">fmt.Println(v1, k1, v2, k2) <span class="comment">// 150 true 0 false</span></span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>语法格式：<code>for k, v := range map &#123;&#125;</code><br>其中<code>k</code>和<code>v</code>是键和值。示例请参考<a href="https://blog.csdn.net/m0_37710023/article/details/106550359">基础小记（4）</a>代码中的第67行。<br>遍历过程是无序的，如果想要有序的遍历，可以将键保存在切片中，通过有序的遍历切片来遍历map。</p><h2 id="删除键值对"><a href="#删除键值对" class="headerlink" title="删除键值对"></a>删除键值对</h2><p>语法格式：<code>delete(map, key)</code><br>接上例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(m1) <span class="comment">// map[体重:300 年龄:25 身高:150]</span></span><br><span class="line"><span class="built_in">delete</span>(m1, <span class="string">&quot;身高&quot;</span>)</span><br><span class="line">fmt.Println(m1) <span class="comment">// map[体重:300 年龄:25]</span></span><br><span class="line"><span class="built_in">delete</span>(m1, <span class="string">&quot;爱好&quot;</span>)</span><br><span class="line">fmt.Println(m1) <span class="comment">// map[体重:300 年龄:25]</span></span><br></pre></td></tr></table></figure><p>如果指定的键是<code>nil</code>或者不存在，<code>delete</code>不做任何操作，所以不会报错。<br><a href="https://www.liwenzhou.com/posts/Go/08_map/">参考</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;map&quot;&gt;&lt;a href=&quot;#map&quot; class=&quot;headerlink&quot; title=&quot;map&quot;&gt;&lt;/a&gt;map&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="Golang" scheme="http://website13.github.io/categories/Golang/"/>
    
    
    <category term="golang" scheme="http://website13.github.io/tags/golang/"/>
    
  </entry>
  
</feed>
